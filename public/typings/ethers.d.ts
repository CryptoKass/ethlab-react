// Generated by dts-bundle-generator v8.0.1

import { Socket } from "net";

declare namespace Ethers {
  /**
   *  The current version of Ethers.
   */
  export declare const version: string;
  /**
   *  Encode %%value%% as a Base58-encoded string.
   */
  export declare function encodeBase58(_value: BytesLike): string;
  /**
   *  Decode the Base58-encoded %%value%%.
   */
  export declare function decodeBase58(value: string): bigint;
  /**
   *  A [[HexString]] whose length is even, which ensures it is a valid
   *  representation of binary data.
   */
  export type DataHexString = string;
  /**
   *  An object that can be used to represent binary data.
   */
  export type BytesLike = DataHexString | Uint8Array;
  /**
   *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
   *  the original %%value%% is returned; if a copy is required use
   *  [[getBytesCopy]].
   *
   *  @see: getBytesCopy
   */
  export declare function getBytes(value: BytesLike, name?: string): Uint8Array;
  /**
   *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
   *  to prevent any modifications of the returned value from being
   *  reflected elsewhere.
   *
   *  @see: getBytes
   */
  export declare function getBytesCopy(
    value: BytesLike,
    name?: string
  ): Uint8Array;
  /**
   *  Returns true if %%value%% is a valid [[HexString]].
   *
   *  If %%length%% is ``true`` or a //number//, it also checks that
   *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
   *  bytes of data (e.g. ``0x1234`` is 2 bytes).
   */
  export declare function isHexString(
    value: any,
    length?: number | boolean
  ): value is `0x${string}`;
  /**
   *  Returns true if %%value%% is a valid representation of arbitrary
   *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
   */
  export declare function isBytesLike(value: any): value is BytesLike;
  /**
   *  Returns a [[DataHexString]] representation of %%data%%.
   */
  export declare function hexlify(data: BytesLike): string;
  /**
   *  Returns a [[DataHexString]] by concatenating all values
   *  within %%data%%.
   */
  export declare function concat(datas: ReadonlyArray<BytesLike>): string;
  /**
   *  Returns the length of %%data%%, in bytes.
   */
  export declare function dataLength(data: BytesLike): number;
  /**
   *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
   *  offset to the %%end%% offset.
   *
   *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
   */
  export declare function dataSlice(
    data: BytesLike,
    start?: number,
    end?: number
  ): string;
  /**
   *  Return the [[DataHexString]] result by stripping all **leading**
   ** zero bytes from %%data%%.
   */
  export declare function stripZerosLeft(data: BytesLike): string;
  /**
   *  Return the [[DataHexString]] of %%data%% padded on the **left**
   *  to %%length%% bytes.
   *
   *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
   *  thrown.
   *
   *  This pads data the same as **values** are in Solidity
   *  (e.g. ``uint128``).
   */
  export declare function zeroPadValue(data: BytesLike, length: number): string;
  /**
   *  Return the [[DataHexString]] of %%data%% padded on the **right**
   *  to %%length%% bytes.
   *
   *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
   *  thrown.
   *
   *  This pads data the same as **bytes** are in Solidity
   *  (e.g. ``bytes16``).
   */
  export declare function zeroPadBytes(data: BytesLike, length: number): string;
  /**
   *  Decodes the base-64 encoded %%value%%.
   *
   *  @example:
   *    // The decoded value is always binary data...
   *    result = decodeBase64("SGVsbG8gV29ybGQhIQ==")
   *    //_result:
   *
   *    // ...use toUtf8String to convert it to a string.
   *    toUtf8String(result)
   *    //_result:
   *
   *    // Decoding binary data
   *    decodeBase64("EjQ=")
   *    //_result:
   */
  export declare function decodeBase64(value: string): Uint8Array;
  /**
   *  Encodes %%data%% as a base-64 encoded string.
   *
   *  @example:
   *    // Encoding binary data as a hexstring
   *    encodeBase64("0x1234")
   *    //_result:
   *
   *    // Encoding binary data as a Uint8Array
   *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))
   *    //_result:
   *
   *    // The input MUST be data...
   *    encodeBase64("Hello World!!")
   *    //_error:
   *
   *    // ...use toUtf8Bytes for this.
   *    encodeBase64(toUtf8Bytes("Hello World!!"))
   *    //_result:
   */
  export declare function encodeBase64(data: BytesLike): string;
  /**
   *  Returns a normalized and checksumed address for %%address%%.
   *  This accepts non-checksum addresses, checksum addresses and
   *  [[getIcapAddress]] formats.
   *
   *  The checksum in Ethereum uses the capitalization (upper-case
   *  vs lower-case) of the characters within an address to encode
   *  its checksum, which offers, on average, a checksum of 15-bits.
   *
   *  If %%address%% contains both upper-case and lower-case, it is
   *  assumed to already be a checksum address and its checksum is
   *  validated, and if the address fails its expected checksum an
   *  error is thrown.
   *
   *  If you wish the checksum of %%address%% to be ignore, it should
   *  be converted to lower-case (i.e. ``.toLowercase()``) before
   *  being passed in. This should be a very rare situation though,
   *  that you wish to bypass the safegaurds in place to protect
   *  against an address that has been incorrectly copied from another
   *  source.
   *
   *  @example:
   *    // Adds the checksum (via upper-casing specific letters)
   *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
   *    //_result:
   *
   *    // Converts ICAP address and adds checksum
   *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
   *    //_result:
   *
   *    // Throws an error if an address contains mixed case,
   *    // but the checksum fails
   *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
   *    //_error:
   */
  export declare function getAddress(address: string): string;
  /**
   *  The [ICAP Address format](link-icap) format is an early checksum
   *  format which attempts to be compatible with the banking
   *  industry [IBAN format](link-wiki-iban) for bank accounts.
   *
   *  It is no longer common or a recommended format.
   *
   *  @example:
   *    getIcapAddress("0x8ba1f109551bd432803012645ac136ddd64dba72");
   *    //_result:
   *
   *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
   *    //_result:
   *
   *    // Throws an error if the ICAP checksum is wrong
   *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37");
   *    //_error:
   */
  export declare function getIcapAddress(address: string): string;
  /**
   *  Returns the address that would result from a ``CREATE`` for %%tx%%.
   *
   *  This can be used to compute the address a contract will be
   *  deployed to by an EOA when sending a deployment transaction (i.e.
   *  when the ``to`` address is ``null``).
   *
   *  This can also be used to compute the address a contract will be
   *  deployed to by a contract, by using the contract's address as the
   *  ``to`` and the contract's nonce.
   *
   *  @example
   *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
   *    nonce = 5;
   *
   *    getCreateAddress({ from, nonce });
   *    //_result:
   */
  export declare function getCreateAddress(tx: {
    from: string;
    nonce: BigNumberish;
  }): string;
  /**
   *  Returns the address that would result from a ``CREATE2`` operation
   *  with the given %%from%%, %%salt%% and %%initCodeHash%%.
   *
   *  To compute the %%initCodeHash%% from a contract's init code, use
   *  the [[keccak256]] function.
   *
   *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].
   *
   *  @example
   *    // The address of the contract
   *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72"
   *
   *    // The salt
   *    salt = id("HelloWorld")
   *
   *    // The hash of the initCode
   *    initCode = "0x6394198df16000526103ff60206004601c335afa6040516060f3";
   *    initCodeHash = keccak256(initCode)
   *
   *    getCreate2Address(from, salt, initCodeHash)
   *    //_result:
   */
  export declare function getCreate2Address(
    _from: string,
    _salt: BytesLike,
    _initCodeHash: BytesLike
  ): string;
  /**
   *  Returns true if %%value%% is an object which implements the
   *  [[Addressable]] interface.
   *
   *  @example:
   *    // Wallets and AbstractSigner sub-classes
   *    isAddressable(Wallet.createRandom())
   *    //_result:
   *
   *    // Contracts
   *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
   *    isAddressable(contract)
   *    //_result:
   */
  export declare function isAddressable(value: any): value is Addressable;
  /**
   *  Returns true if %%value%% is a valid address.
   *
   *  @example:
   *    // Valid address
   *    isAddress("0x8ba1f109551bD432803012645Ac136ddd64DBA72")
   *    //_result:
   *
   *    // Valid ICAP address
   *    isAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36")
   *    //_result:
   *
   *    // Invalid checksum
   *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBa72")
   *    //_result:
   *
   *    // Invalid ICAP checksum
   *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
   *    //_result:
   *
   *    // Not an address (an ENS name requires a provided and an
   *    // asynchronous API to access)
   *    isAddress("ricmoo.eth")
   *    //_result:
   */
  export declare function isAddress(value: any): value is string;
  /**
   *  Resolves to an address for the %%target%%, which may be any
   *  supported address type, an [[Addressable]] or a Promise which
   *  resolves to an address.
   *
   *  If an ENS name is provided, but that name has not been correctly
   *  configured a [[UnconfiguredNameError]] is thrown.
   *
   *  @example:
   *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
   *
   *    // Addresses are return synchronously
   *    resolveAddress(addr, provider)
   *    //_result:
   *
   *    // Address promises are resolved asynchronously
   *    resolveAddress(Promise.resolve(addr))
   *    //_result:
   *
   *    // ENS names are resolved asynchronously
   *    resolveAddress("dai.tokens.ethers.eth", provider)
   *    //_result:
   *
   *    // Addressable objects are resolved asynchronously
   *    contract = new Contract(addr, [ ])
   *    resolveAddress(contract, provider)
   *    //_result:
   *
   *    // Unconfigured ENS names reject
   *    resolveAddress("nothing-here.ricmoo.eth", provider)
   *    //_error:
   *
   *    // ENS names require a NameResolver object passed in
   *    // (notice the provider was omitted)
   *    resolveAddress("nothing-here.ricmoo.eth")
   *    //_error:
   */
  export declare function resolveAddress(
    target: AddressLike,
    resolver?: null | NameResolver
  ): string | Promise<string>;
  /**
   *  Addresses are a fundamental part of interacting with Ethereum. They
   *  represent the gloabal identity of Externally Owned Accounts (accounts
   *  backed by a private key) and contracts.
   *
   *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem
   *  of contracts, standards and libraries which enable looking up an
   *  address for an ENS name.
   *
   *  These functions help convert between various formats, validate
   *  addresses and safely resolve ENS names.
   *
   *  @_section: api/address:Addresses  [about-addresses]
   */
  /**
   *  An interface for objects which have an address, and can
   *  resolve it asyncronously.
   *
   *  This allows objects such as [[Signer]] or [[Contract]] to
   *  be used most places an address can be, for example getting
   *  the [balance](Provider-getBalance).
   */
  export interface Addressable {
    /**
     *  Get the object address.
     */
    getAddress(): Promise<string>;
  }
  /**
   *  Anything that can be used to return or resolve an address.
   */
  export type AddressLike = string | Promise<string> | Addressable;
  /**
   *  An interface for any object which can resolve an ENS name.
   */
  export interface NameResolver {
    /**
     *  Resolve to the address for the ENS %%name%%.
     *
     *  Resolves to ``null`` if the name is unconfigued. Use
     *  [[resolveAddress]] (passing this object as %%resolver%%) to
     *  throw for names that are unconfigured.
     */
    resolveName(name: string): Promise<null | string>;
  }
  /**
   *  Return the HMAC for %%data%% using the %%key%% key with the underlying
   *  %%algo%% used for compression.
   *
   *  @example:
   *    key = id("some-secret")
   *
   *    // Compute the HMAC
   *    computeHmac("sha256", key, "0x1337")
   *    //_result:
   *
   *    // To compute the HMAC of UTF-8 data, the data must be
   *    // converted to UTF-8 bytes
   *    computeHmac("sha256", key, toUtf8Bytes("Hello World"))
   *    //_result:
   *
   */
  export declare function computeHmac(
    algorithm: "sha256" | "sha512",
    _key: BytesLike,
    _data: BytesLike
  ): string;
  export declare namespace computeHmac {
    var _: (
      algorithm: "sha256" | "sha512",
      key: Uint8Array,
      data: Uint8Array
    ) => BytesLike;
    var lock: () => void;
    var register: (
      func: (
        algorithm: "sha256" | "sha512",
        key: Uint8Array,
        data: Uint8Array
      ) => BytesLike
    ) => void;
  }
  /**
   *  Compute the cryptographic KECCAK256 hash of %%data%%.
   *
   *  The %%data%% **must** be a data representation, to compute the
   *  hash of UTF-8 data use the [[id]] function.
   *
   *  @returns DataHexstring
   *  @example:
   *    keccak256("0x")
   *    //_result:
   *
   *    keccak256("0x1337")
   *    //_result:
   *
   *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   *
   *    // Strings are assumed to be DataHexString, otherwise it will
   *    // throw. To hash UTF-8 data, see the note above.
   *    keccak256("Hello World")
   *    //_error:
   */
  export declare function keccak256(_data: BytesLike): string;
  export declare namespace keccak256 {
    var _: (data: Uint8Array) => Uint8Array;
    var lock: () => void;
    var register: (func: (data: Uint8Array) => BytesLike) => void;
  }
  /**
   *  Compute the cryptographic RIPEMD-160 hash of %%data%%.
   *
   *  @_docloc: api/crypto:Hash Functions
   *  @returns DataHexstring
   *
   *  @example:
   *    ripemd160("0x")
   *    //_result:
   *
   *    ripemd160("0x1337")
   *    //_result:
   *
   *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   *
   */
  export declare function ripemd160(_data: BytesLike): string;
  export declare namespace ripemd160 {
    var _: (data: Uint8Array) => Uint8Array;
    var lock: () => void;
    var register: (func: (data: Uint8Array) => BytesLike) => void;
  }
  /**
   *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using
   *  the %%salt%% and using %%iterations%% of %%algo%%.
   *
   *  This PBKDF is outdated and should not be used in new projects, but is
   *  required to decrypt older files.
   *
   *  @example:
   *    // The password must be converted to bytes, and it is generally
   *    // best practices to ensure the string has been normalized. Many
   *    // formats explicitly indicate the normalization form to use.
   *    password = "hello"
   *    passwordBytes = toUtf8Bytes(password, "NFKC")
   *
   *    salt = id("some-salt")
   *
   *    // Compute the PBKDF2
   *    pbkdf2(passwordBytes, salt, 1024, 16, "sha256")
   *    //_result:
   */
  export declare function pbkdf2(
    _password: BytesLike,
    _salt: BytesLike,
    iterations: number,
    keylen: number,
    algo: "sha256" | "sha512"
  ): string;
  export declare namespace pbkdf2 {
    var _: (
      password: Uint8Array,
      salt: Uint8Array,
      iterations: number,
      keylen: number,
      algo: "sha256" | "sha512"
    ) => BytesLike;
    var lock: () => void;
    var register: (
      func: (
        password: Uint8Array,
        salt: Uint8Array,
        iterations: number,
        keylen: number,
        algo: "sha256" | "sha512"
      ) => BytesLike
    ) => void;
  }
  /**
   *  Return %%length%% bytes of cryptographically secure random data.
   *
   *  @example:
   *    randomBytes(8)
   *    //_result:
   */
  export declare function randomBytes(length: number): Uint8Array;
  export declare namespace randomBytes {
    var _: (length: number) => Uint8Array;
    var lock: () => void;
    var register: (func: (length: number) => Uint8Array) => void;
  }
  /**
   *  A callback during long-running operations to update any
   *  UI or provide programatic access to the progress.
   *
   *  The %%percent%% is a value between ``0`` and ``1``.
   *
   *  @_docloc: api/crypto:Passwords
   */
  export type ProgressCallback = (percent: number) => void;
  /**
   *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of
   *  derivation to increase the resource cost to brute-force a password
   *  for a given key.
   *
   *  This means this algorithm is intentionally slow, and can be tuned to
   *  become slower. As computation and memory speed improve over time,
   *  increasing the difficulty maintains the cost of an attacker.
   *
   *  For example, if a target time of 5 seconds is used, a legitimate user
   *  which knows their password requires only 5 seconds to unlock their
   *  account. A 6 character password has 68 billion possibilities, which
   *  would require an attacker to invest over 10,000 years of CPU time. This
   *  is of course a crude example (as password generally aren't random),
   *  but demonstrates to value of imposing large costs to decryption.
   *
   *  For this reason, if building a UI which involved decrypting or
   *  encrypting datsa using scrypt, it is recommended to use a
   *  [[ProgressCallback]] (as event short periods can seem lik an eternity
   *  if the UI freezes). Including the phrase //"decrypting"// in the UI
   *  can also help, assuring the user their waiting is for a good reason.
   *
   *  @_docloc: api/crypto:Passwords
   *
   *  @example:
   *    // The password must be converted to bytes, and it is generally
   *    // best practices to ensure the string has been normalized. Many
   *    // formats explicitly indicate the normalization form to use.
   *    password = "hello"
   *    passwordBytes = toUtf8Bytes(password, "NFKC")
   *
   *    salt = id("some-salt")
   *
   *    // Compute the scrypt
   *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)
   *    //_result:
   */
  export declare function scrypt(
    _passwd: BytesLike,
    _salt: BytesLike,
    N: number,
    r: number,
    p: number,
    dkLen: number,
    progress?: ProgressCallback
  ): Promise<string>;
  export declare namespace scrypt {
    var _: (
      passwd: Uint8Array,
      salt: Uint8Array,
      N: number,
      r: number,
      p: number,
      dkLen: number,
      onProgress?: ProgressCallback | undefined
    ) => Promise<Uint8Array>;
    var lock: () => void;
    var register: (
      func: (
        passwd: Uint8Array,
        salt: Uint8Array,
        N: number,
        r: number,
        p: number,
        dkLen: number,
        progress?: ProgressCallback | undefined
      ) => Promise<BytesLike>
    ) => void;
  }
  /**
   *  Provides a synchronous variant of [[scrypt]].
   *
   *  This will completely lock up and freeze the UI in a browser and will
   *  prevent any event loop from progressing. For this reason, it is
   *  preferred to use the [async variant](scrypt).
   *
   *  @_docloc: api/crypto:Passwords
   *
   *  @example:
   *    // The password must be converted to bytes, and it is generally
   *    // best practices to ensure the string has been normalized. Many
   *    // formats explicitly indicate the normalization form to use.
   *    password = "hello"
   *    passwordBytes = toUtf8Bytes(password, "NFKC")
   *
   *    salt = id("some-salt")
   *
   *    // Compute the scrypt
   *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)
   *    //_result:
   */
  export declare function scryptSync(
    _passwd: BytesLike,
    _salt: BytesLike,
    N: number,
    r: number,
    p: number,
    dkLen: number
  ): string;
  export declare namespace scryptSync {
    var _: (
      passwd: Uint8Array,
      salt: Uint8Array,
      N: number,
      r: number,
      p: number,
      dkLen: number
    ) => Uint8Array;
    var lock: () => void;
    var register: (
      func: (
        passwd: Uint8Array,
        salt: Uint8Array,
        N: number,
        r: number,
        p: number,
        dkLen: number
      ) => BytesLike
    ) => void;
  }
  /**
   *  Compute the cryptographic SHA2-256 hash of %%data%%.
   *
   *  @_docloc: api/crypto:Hash Functions
   *  @returns DataHexstring
   *
   *  @example:
   *    sha256("0x")
   *    //_result:
   *
   *    sha256("0x1337")
   *    //_result:
   *
   *    sha256(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   *
   */
  export declare function sha256(_data: BytesLike): string;
  export declare namespace sha256 {
    var _: (data: Uint8Array) => Uint8Array;
    var lock: () => void;
    var register: (func: (data: Uint8Array) => BytesLike) => void;
  }
  /**
   *  Compute the cryptographic SHA2-512 hash of %%data%%.
   *
   *  @_docloc: api/crypto:Hash Functions
   *  @returns DataHexstring
   *
   *  @example:
   *    sha512("0x")
   *    //_result:
   *
   *    sha512("0x1337")
   *    //_result:
   *
   *    sha512(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   */
  export declare function sha512(_data: BytesLike): string;
  export declare namespace sha512 {
    var _: (data: Uint8Array) => Uint8Array;
    var lock: () => void;
    var register: (func: (data: Uint8Array) => BytesLike) => void;
  }
  /**
   *  A SignatureLike
   *
   *  @_docloc: api/crypto:Signing
   */
  export type SignatureLike =
    | Signature
    | string
    | {
        r: string;
        s: string;
        v: BigNumberish;
        yParity?: 0 | 1;
        yParityAndS?: string;
      }
    | {
        r: string;
        yParityAndS: string;
        yParity?: 0 | 1;
        s?: string;
        v?: number;
      }
    | {
        r: string;
        s: string;
        yParity: 0 | 1;
        v?: BigNumberish;
        yParityAndS?: string;
      };
  /**
   *  A Signature  @TODO
   *
   *
   *  @_docloc: api/crypto:Signing
   */
  export declare class Signature {
    #private;
    /**
     *  The ``r`` value for a signautre.
     *
     *  This represents the ``x`` coordinate of a "reference" or
     *  challenge point, from which the ``y`` can be computed.
     */
    get r(): string;
    set r(value: BytesLike);
    /**
     *  The ``s`` value for a signature.
     */
    get s(): string;
    set s(_value: BytesLike);
    /**
     *  The ``v`` value for a signature.
     *
     *  Since a given ``x`` value for ``r`` has two possible values for
     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
     *  values to use.
     *
     *  It is normalized to the values ``27`` or ``28`` for legacy
     *  purposes.
     */
    get v(): 27 | 28;
    set v(value: BigNumberish);
    /**
     *  The EIP-155 ``v`` for legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get networkV(): null | bigint;
    /**
     *  The chain ID for EIP-155 legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get legacyChainId(): null | bigint;
    /**
     *  The ``yParity`` for the signature.
     *
     *  See ``v`` for more details on how this value is used.
     */
    get yParity(): 0 | 1;
    /**
     *  The [[link-eip-2098]] compact representation of the ``yParity``
     *  and ``s`` compacted into a single ``bytes32``.
     */
    get yParityAndS(): string;
    /**
     *  The [[link-eip-2098]] compact representation.
     */
    get compactSerialized(): string;
    /**
     *  The serialized representation.
     */
    get serialized(): string;
    /**
     *  @private
     */
    constructor(guard: any, r: string, s: string, v: 27 | 28);
    /**
     *  Returns a new identical [[Signature]].
     */
    clone(): Signature;
    /**
     *  Returns a representation that is compatible with ``JSON.stringify``.
     */
    toJSON(): any;
    /**
     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
     *
     *  @example:
     *    Signature.getChainId(45)
     *    //_result:
     *
     *    Signature.getChainId(46)
     *    //_result:
     */
    static getChainId(v: BigNumberish): bigint;
    /**
     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
     *
     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
     *  property to include the chain ID.
     *
     *  @example:
     *    Signature.getChainIdV(5, 27)
     *    //_result:
     *
     *    Signature.getChainIdV(5, 28)
     *    //_result:
     *
     */
    static getChainIdV(chainId: BigNumberish, v: 27 | 28): bigint;
    /**
     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
     *
     *  @example:
     *    // The values 0 and 1 imply v is actually yParity
     *    Signature.getNormalizedV(0)
     *    //_result:
     *
     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
     *    Signature.getNormalizedV(27)
     *    //_result:
     *
     *    // Legacy EIP-155 transaction (i.e. >= 35)
     *    Signature.getNormalizedV(46)
     *    //_result:
     *
     *    // Invalid values throw
     *    Signature.getNormalizedV(5)
     *    //_error:
     */
    static getNormalizedV(v: BigNumberish): 27 | 28;
    /**
     *  Creates a new [[Signature]].
     *
     *  If no %%sig%% is provided, a new [[Signature]] is created
     *  with default values.
     *
     *  If %%sig%% is a string, it is parsed.
     */
    static from(sig?: SignatureLike): Signature;
  }
  /**
   *  A **SigningKey** provides high-level access to the elliptic curve
   *  cryptography (ECC) operations and key management.
   */
  export declare class SigningKey {
    #private;
    /**
     *  Creates a new **SigningKey** for %%privateKey%%.
     */
    constructor(privateKey: BytesLike);
    /**
     *  The private key.
     */
    get privateKey(): string;
    /**
     *  The uncompressed public key.
     *
     * This will always begin with the prefix ``0x04`` and be 132
     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
     */
    get publicKey(): string;
    /**
     *  The compressed public key.
     *
     *  This will always begin with either the prefix ``0x02`` or ``0x03``
     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
     *  nibbles)
     */
    get compressedPublicKey(): string;
    /**
     *  Return the signature of the signed %%digest%%.
     */
    sign(digest: BytesLike): Signature;
    /**
     *  Returns the [[link-wiki-ecdh]] shared secret between this
     *  private key and the %%other%% key.
     *
     *  The %%other%% key may be any type of key, a raw public key,
     *  a compressed/uncompressed pubic key or aprivate key.
     *
     *  Best practice is usually to use a cryptographic hash on the
     *  returned value before using it as a symetric secret.
     *
     *  @example:
     *    sign1 = new SigningKey(id("some-secret-1"))
     *    sign2 = new SigningKey(id("some-secret-2"))
     *
     *    // Notice that privA.computeSharedSecret(pubB)...
     *    sign1.computeSharedSecret(sign2.publicKey)
     *    //_result:
     *
     *    // ...is equal to privB.computeSharedSecret(pubA).
     *    sign2.computeSharedSecret(sign1.publicKey)
     *    //_result:
     */
    computeSharedSecret(other: BytesLike): string;
    /**
     *  Compute the public key for %%key%%, optionally %%compressed%%.
     *
     *  The %%key%% may be any type of key, a raw public key, a
     *  compressed/uncompressed public key or private key.
     *
     *  @example:
     *    sign = new SigningKey(id("some-secret"));
     *
     *    // Compute the uncompressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey)
     *    //_result:
     *
     *    // Compute the compressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey, true)
     *    //_result:
     *
     *    // Compute the uncompressed public key
     *    SigningKey.computePublicKey(sign.publicKey, false);
     *    //_result:
     *
     *    // Compute the Compressed a public key
     *    SigningKey.computePublicKey(sign.publicKey, true);
     *    //_result:
     */
    static computePublicKey(key: BytesLike, compressed?: boolean): string;
    /**
     *  Returns the public key for the private key which produced the
     *  %%signature%% for the given %%digest%%.
     *
     *  @example:
     *    key = new SigningKey(id("some-secret"))
     *    digest = id("hello world")
     *    sig = key.sign(digest)
     *
     *    // Notice the signer public key...
     *    key.publicKey
     *    //_result:
     *
     *    // ...is equal to the recovered public key
     *    SigningKey.recoverPublicKey(digest, sig)
     *    //_result:
     *
     */
    static recoverPublicKey(
      digest: BytesLike,
      signature: SignatureLike
    ): string;
    /**
     *  Returns the point resulting from adding the ellipic curve points
     *  %%p0%% and %%p1%%.
     *
     *  This is not a common function most developers should require, but
     *  can be useful for certain privacy-specific techniques.
     *
     *  For example, it is used by [[HDNodeWallet]] to compute child
     *  addresses from parent public keys and chain codes.
     */
    static addPoints(
      p0: BytesLike,
      p1: BytesLike,
      compressed?: boolean
    ): string;
  }
  /**
   *  Once called, prevents any future change to the underlying cryptographic
   *  primitives using the ``.register`` feature for hooks.
   */
  export declare function lock(): void;
  /**
   *  Returns a [[AccessList]] from any ethers-supported access-list structure.
   */
  export declare function accessListify(value: AccessListish): AccessList;
  /**
   *  Returns the address for the %%key%%.
   *
   *  The key may be any standard form of public key or a private key.
   */
  export declare function computeAddress(key: string | SigningKey): string;
  /**
   *  Returns the recovered address for the private key that was
   *  used to sign %%digest%% that resulted in %%signature%%.
   */
  export declare function recoverAddress(
    digest: BytesLike,
    signature: SignatureLike
  ): string;
  /**
   *  A **TransactionLike** is an object which is appropriate as a loose
   *  input for many operations which will populate missing properties of
   *  a transaction.
   */
  export interface TransactionLike<A = string> {
    /**
     *  The type.
     */
    type?: null | number;
    /**
     *  The recipient address or ``null`` for an ``init`` transaction.
     */
    to?: null | A;
    /**
     *  The sender.
     */
    from?: null | A;
    /**
     *  The nonce.
     */
    nonce?: null | number;
    /**
     *  The maximum amount of gas that can be used.
     */
    gasLimit?: null | BigNumberish;
    /**
     *  The gas price for legacy and berlin transactions.
     */
    gasPrice?: null | BigNumberish;
    /**
     *  The maximum priority fee per gas for london transactions.
     */
    maxPriorityFeePerGas?: null | BigNumberish;
    /**
     *  The maximum total fee per gas for london transactions.
     */
    maxFeePerGas?: null | BigNumberish;
    /**
     *  The data.
     */
    data?: null | string;
    /**
     *  The value (in wei) to send.
     */
    value?: null | BigNumberish;
    /**
     *  The chain ID the transaction is valid on.
     */
    chainId?: null | BigNumberish;
    /**
     *  The transaction hash.
     */
    hash?: null | string;
    /**
     *  The signature provided by the sender.
     */
    signature?: null | SignatureLike;
    /**
     *  The access list for berlin and london transactions.
     */
    accessList?: null | AccessListish;
  }
  /**
   *  A **Transaction** describes an operation to be executed on
   *  Ethereum by an Externally Owned Account (EOA). It includes
   *  who (the [[to]] address), what (the [[data]]) and how much (the
   *  [[value]] in ether) the operation should entail.
   *
   *  @example:
   *    tx = new Transaction()
   *    //_result:
   *
   *    tx.data = "0x1234";
   *    //_result:
   */
  export declare class Transaction implements TransactionLike<string> {
    #private;
    /**
     *  The transaction type.
     *
     *  If null, the type will be automatically inferred based on
     *  explicit properties.
     */
    get type(): null | number;
    set type(value: null | number | string);
    /**
     *  The name of the transaction type.
     */
    get typeName(): null | string;
    /**
     *  The ``to`` address for the transaction or ``null`` if the
     *  transaction is an ``init`` transaction.
     */
    get to(): null | string;
    set to(value: null | string);
    /**
     *  The transaction nonce.
     */
    get nonce(): number;
    set nonce(value: BigNumberish);
    /**
     *  The gas limit.
     */
    get gasLimit(): bigint;
    set gasLimit(value: BigNumberish);
    /**
     *  The gas price.
     *
     *  On legacy networks this defines the fee that will be paid. On
     *  EIP-1559 networks, this should be ``null``.
     */
    get gasPrice(): null | bigint;
    set gasPrice(value: null | BigNumberish);
    /**
     *  The maximum priority fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
    get maxPriorityFeePerGas(): null | bigint;
    set maxPriorityFeePerGas(value: null | BigNumberish);
    /**
     *  The maximum total fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
    get maxFeePerGas(): null | bigint;
    set maxFeePerGas(value: null | BigNumberish);
    /**
     *  The transaction data. For ``init`` transactions this is the
     *  deployment code.
     */
    get data(): string;
    set data(value: BytesLike);
    /**
     *  The amount of ether (in wei) to send in this transactions.
     */
    get value(): bigint;
    set value(value: BigNumberish);
    /**
     *  The chain ID this transaction is valid on.
     */
    get chainId(): bigint;
    set chainId(value: BigNumberish);
    /**
     *  If signed, the signature for this transaction.
     */
    get signature(): null | Signature;
    set signature(value: null | SignatureLike);
    /**
     *  The access list.
     *
     *  An access list permits discounted (but pre-paid) access to
     *  bytecode and state variable access within contract execution.
     */
    get accessList(): null | AccessList;
    set accessList(value: null | AccessListish);
    /**
     *  Creates a new Transaction with default values.
     */
    constructor();
    /**
     *  The transaction hash, if signed. Otherwise, ``null``.
     */
    get hash(): null | string;
    /**
     *  The pre-image hash of this transaction.
     *
     *  This is the digest that a [[Signer]] must sign to authorize
     *  this transaction.
     */
    get unsignedHash(): string;
    /**
     *  The sending address, if signed. Otherwise, ``null``.
     */
    get from(): null | string;
    /**
     *  The public key of the sender, if signed. Otherwise, ``null``.
     */
    get fromPublicKey(): null | string;
    /**
     *  Returns true if signed.
     *
     *  This provides a Type Guard that properties requiring a signed
     *  transaction are non-null.
     */
    isSigned(): this is Transaction & {
      type: number;
      typeName: string;
      from: string;
      signature: Signature;
    };
    /**
     *  The serialized transaction.
     *
     *  This throws if the transaction is unsigned. For the pre-image,
     *  use [[unsignedSerialized]].
     */
    get serialized(): string;
    /**
     *  The transaction pre-image.
     *
     *  The hash of this is the digest which needs to be signed to
     *  authorize this transaction.
     */
    get unsignedSerialized(): string;
    /**
     *  Return the most "likely" type; currently the highest
     *  supported transaction type.
     */
    inferType(): number;
    /**
     *  Validates the explicit properties and returns a list of compatible
     *  transaction types.
     */
    inferTypes(): Array<number>;
    /**
     *  Returns true if this transaction is a legacy transaction (i.e.
     *  ``type === 0``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isLegacy(): this is Transaction & {
      type: 0;
      gasPrice: bigint;
    };
    /**
     *  Returns true if this transaction is berlin hardform transaction (i.e.
     *  ``type === 1``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isBerlin(): this is Transaction & {
      type: 1;
      gasPrice: bigint;
      accessList: AccessList;
    };
    /**
     *  Returns true if this transaction is london hardform transaction (i.e.
     *  ``type === 2``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
    isLondon(): this is Transaction & {
      type: 2;
      accessList: AccessList;
      maxFeePerGas: bigint;
      maxPriorityFeePerGas: bigint;
    };
    /**
     *  Create a copy of this transaciton.
     */
    clone(): Transaction;
    /**
     *  Return a JSON-friendly object.
     */
    toJSON(): any;
    /**
     *  Create a **Transaction** from a serialized transaction or a
     *  Transaction-like object.
     */
    static from(tx?: string | TransactionLike<string>): Transaction;
  }
  /**
   *  Each state-changing operation on Ethereum requires a transaction.
   *
   *  @_section api/transaction:Transactions  [about-transactions]
   */
  /**
   *  A single [[AccessList]] entry of storage keys (slots) for an address.
   */
  export type AccessListEntry = {
    address: string;
    storageKeys: Array<string>;
  };
  /**
   *  An ordered collection of [[AccessList]] entries.
   */
  export type AccessList = Array<AccessListEntry>;
  /**
   *  Any ethers-supported access list structure.
   */
  export type AccessListish =
    | AccessList
    | Array<[string, Array<string>]>
    | Record<string, Array<string>>;
  /**
   *  A **ContractRunner** is a generic interface which defines an object
   *  capable of interacting with a Contract on the network.
   *
   *  The more operations supported, the more utility it is capable of.
   *
   *  The most common ContractRunners are [Providers](Provider) which enable
   *  read-only access and [Signers](Signer) which enable write-access.
   */
  export interface ContractRunner {
    /**
     *  The provider used for necessary state querying operations.
     *
     *  This can also point to the **ContractRunner** itself, in the
     *  case of an [[AbstractProvider]].
     */
    provider: null | Provider;
    /**
     *  Required to estimate gas.
     */
    estimateGas?: (tx: TransactionRequest) => Promise<bigint>;
    /**
     * Required for pure, view or static calls to contracts.
     */
    call?: (tx: TransactionRequest) => Promise<string>;
    /**
     *  Required to support ENS names
     */
    resolveName?: (name: string) => Promise<null | string>;
    /**
     *  Required for state mutating calls
     */
    sendTransaction?: (tx: TransactionRequest) => Promise<TransactionResponse>;
  }
  /**
   *  A **NetworkPlugin** provides additional functionality on a [[Network]].
   */
  export declare class NetworkPlugin {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    readonly name: string;
    /**
     *  Creates a new **NetworkPlugin**.
     */
    constructor(name: string);
    /**
     *  Creates a copy of this plugin.
     */
    clone(): NetworkPlugin;
  }
  /**
   *  The gas cost parameters for a [[GasCostPlugin]].
   */
  export type GasCostParameters = {
    /**
     *  The transactions base fee.
     */
    txBase?: number;
    /**
     *  The fee for creating a new account.
     */
    txCreate?: number;
    /**
     *  The fee per zero-byte in the data.
     */
    txDataZero?: number;
    /**
     *  The fee per non-zero-byte in the data.
     */
    txDataNonzero?: number;
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    txAccessListStorageKey?: number;
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    txAccessListAddress?: number;
  };
  /**
   *  A **GasCostPlugin** allows a network to provide alternative values when
   *  computing the intrinsic gas required for a transaction.
   */
  export declare class GasCostPlugin
    extends NetworkPlugin
    implements GasCostParameters
  {
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    readonly effectiveBlock: number;
    /**
     *  The transactions base fee.
     */
    readonly txBase: number;
    /**
     *  The fee for creating a new account.
     */
    readonly txCreate: number;
    /**
     *  The fee per zero-byte in the data.
     */
    readonly txDataZero: number;
    /**
     *  The fee per non-zero-byte in the data.
     */
    readonly txDataNonzero: number;
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    readonly txAccessListStorageKey: number;
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    readonly txAccessListAddress: number;
    /**
     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
     *  latest block or another GasCostPlugin supercedes that block number,
     *  with the associated %%costs%%.
     */
    constructor(effectiveBlock?: number, costs?: GasCostParameters);
    clone(): GasCostPlugin;
  }
  /**
   *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry
   *  Contract address and the target network to use when using that
   *  contract.
   *
   *  Various testnets have their own instance of the contract to use, but
   *  in general, the mainnet instance supports multi-chain addresses and
   *  should be used.
   */
  export declare class EnsPlugin extends NetworkPlugin {
    /**
     *  The ENS Registrty Contract address.
     */
    readonly address: string;
    /**
     *  The chain ID that the ENS contract lives on.
     */
    readonly targetNetwork: number;
    /**
     *  Creates a new **EnsPlugin** connected to %%address%% on the
     *  %%targetNetwork%%. The default ENS address and mainnet is used
     *  if unspecified.
     */
    constructor(address?: null | string, targetNetwork?: null | number);
    clone(): EnsPlugin;
  }
  /**
   *  A **FeeDataNetworkPlugin** allows a network to provide and alternate
   *  means to specify its fee data.
   *
   *  For example, a network which does not support [[link-eip-1559]] may
   *  choose to use a Gas Station site to approximate the gas price.
   */
  export declare class FeeDataNetworkPlugin extends NetworkPlugin {
    #private;
    /**
     *  The fee data function provided to the constructor.
     */
    get feeDataFunc(): (provider: Provider) => Promise<FeeData>;
    /**
     *  Creates a new **FeeDataNetworkPlugin**.
     */
    constructor(feeDataFunc: (provider: Provider) => Promise<FeeData>);
    /**
     *  Resolves to the fee data.
     */
    getFeeData(provider: Provider): Promise<FeeData>;
    clone(): FeeDataNetworkPlugin;
  }
  /**
   *  A Networkish can be used to allude to a Network, by specifing:
   *  - a [[Network]] object
   *  - a well-known (or registered) network name
   *  - a well-known (or registered) chain ID
   *  - an object with sufficient details to describe a network
   */
  export type Networkish =
    | Network
    | number
    | bigint
    | string
    | {
        name?: string;
        chainId?: number;
        ensAddress?: string;
        ensNetwork?: number;
      };
  /**
   *  A **Network** provides access to a chain's properties and allows
   *  for plug-ins to extend functionality.
   */
  export declare class Network {
    #private;
    /**
     *  Creates a new **Network** for %%name%% and %%chainId%%.
     */
    constructor(name: string, chainId: BigNumberish);
    /**
     *  Returns a JSON-compatible representation of a Network.
     */
    toJSON(): any;
    /**
     *  The network common name.
     *
     *  This is the canonical name, as networks migh have multiple
     *  names.
     */
    get name(): string;
    set name(value: string);
    /**
     *  The network chain ID.
     */
    get chainId(): bigint;
    set chainId(value: BigNumberish);
    /**
     *  Returns true if %%other%% matches this network. Any chain ID
     *  must match, and if no chain ID is present, the name must match.
     *
     *  This method does not currently check for additional properties,
     *  such as ENS address or plug-in compatibility.
     */
    matches(other: Networkish): boolean;
    /**
     *  Returns the list of plugins currently attached to this Network.
     */
    get plugins(): Array<NetworkPlugin>;
    /**
     *  Attach a new %%plugin%% to this Network. The network name
     *  must be unique, excluding any fragment.
     */
    attachPlugin(plugin: NetworkPlugin): this;
    /**
     *  Return the plugin, if any, matching %%name%% exactly. Plugins
     *  with fragments will not be returned unless %%name%% includes
     *  a fragment.
     */
    getPlugin<T extends NetworkPlugin = NetworkPlugin>(name: string): null | T;
    /**
     *  Gets a list of all plugins that match %%name%%, with otr without
     *  a fragment.
     */
    getPlugins<T extends NetworkPlugin = NetworkPlugin>(
      basename: string
    ): Array<T>;
    /**
     *  Create a copy of this Network.
     */
    clone(): Network;
    /**
     *  Compute the intrinsic gas required for a transaction.
     *
     *  A GasCostPlugin can be attached to override the default
     *  values.
     */
    computeIntrinsicGas(tx: TransactionLike): number;
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
    static from(network?: Networkish): Network;
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
    static register(
      nameOrChainId: string | number | bigint,
      networkFunc: () => Network
    ): void;
  }
  /**
   *  a **BlockParams** encodes the minimal required properties for a
   *  formatted block.
   */
  export interface BlockParams {
    /**
     *  The block hash.
     */
    hash?: null | string;
    /**
     *  The block number.
     */
    number: number;
    /**
     *  The timestamp for this block, which is the number of seconds
     *  since epoch that this block was included.
     */
    timestamp: number;
    /**
     *  The hash of the previous block in the blockchain. The genesis block
     *  has the parentHash of the [[ZeroHash]].
     */
    parentHash: string;
    /**
     *  A random sequence provided during the mining process for
     *  proof-of-work networks.
     */
    nonce: string;
    /**
     *  For proof-of-work networks, the difficulty target is used to
     *  adjust the difficulty in mining to ensure a expected block rate.
     */
    difficulty: bigint;
    /**
     *  The maximum amount of gas a block can consume.
     */
    gasLimit: bigint;
    /**
     *  The amount of gas a block consumed.
     */
    gasUsed: bigint;
    /**
     *  The miner (or author) of a block.
     */
    miner: string;
    /**
     *  Additional data the miner choose to include.
     */
    extraData: string;
    /**
     *  The protocol-defined base fee per gas in an [[link-eip-1559]]
     *  block.
     */
    baseFeePerGas: null | bigint;
    /**
     *  The list of transactions in the block.
     */
    transactions: ReadonlyArray<string | TransactionResponseParams>;
  }
  /**
   *  a **LogParams** encodes the minimal required properties for a
   *  formatted log.
   */
  export interface LogParams {
    /**
     *  The transaction hash for the transaxction the log occurred in.
     */
    transactionHash: string;
    /**
     *  The block hash of the block that included the transaction for this
     *  log.
     */
    blockHash: string;
    /**
     *  The block number of the block that included the transaction for this
     *  log.
     */
    blockNumber: number;
    /**
     *  Whether this log was removed due to the transaction it was included
     *  in being removed dur to an orphaned block.
     */
    removed: boolean;
    /**
     *  The address of the contract that emitted this log.
     */
    address: string;
    /**
     *  The data emitted with this log.
     */
    data: string;
    /**
     *  The topics emitted with this log.
     */
    topics: ReadonlyArray<string>;
    /**
     *  The index of this log.
     */
    index: number;
    /**
     *  The transaction index of this log.
     */
    transactionIndex: number;
  }
  /**
   *  a **TransactionReceiptParams** encodes the minimal required properties
   *  for a formatted transaction receipt.
   */
  export interface TransactionReceiptParams {
    /**
     *  The target of the transaction. If null, the transaction was trying
     *  to deploy a transaction with the ``data`` as the initi=code.
     */
    to: null | string;
    /**
     *  The sender of the transaction.
     */
    from: string;
    /**
     *  If the transaction was directly deploying a contract, the [[to]]
     *  will be null, the ``data`` will be initcode and if successful, this
     *  will be the address of the contract deployed.
     */
    contractAddress: null | string;
    /**
     *  The transaction hash.
     */
    hash: string;
    /**
     *  The transaction index.
     */
    index: number;
    /**
     *  The block hash of the block that included this transaction.
     */
    blockHash: string;
    /**
     *  The block number of the block that included this transaction.
     */
    blockNumber: number;
    /**
     *  The bloom filter for the logs emitted during execution of this
     *  transaction.
     */
    logsBloom: string;
    /**
     *  The logs emitted during the execution of this transaction.
     */
    logs: ReadonlyArray<LogParams>;
    /**
     *  The amount of gas consumed executing this transaciton.
     */
    gasUsed: bigint;
    /**
     *  The total amount of gas consumed during the entire block up to
     *  and including this transaction.
     */
    cumulativeGasUsed: bigint;
    /**
     *  The actual gas price per gas charged for this transaction.
     */
    gasPrice?: null | bigint;
    /**
     *  The actual gas price per gas charged for this transaction.
     */
    effectiveGasPrice?: null | bigint;
    /**
     *  The [[link-eip-2718]] envelope type.
     */
    type: number;
    /**
     *  The status of the transaction execution. If ``1`` then the
     *  the transaction returned success, if ``0`` then the transaction
     *  was reverted. For pre-byzantium blocks, this is usually null, but
     *  some nodes may have backfilled this data.
     */
    status: null | number;
    /**
     *  The root of this transaction in a pre-bazatium block. In
     *  post-byzantium blocks this is null.
     */
    root: null | string;
  }
  /**
   *  a **TransactionResponseParams** encodes the minimal required properties
   *  for a formatted transaction response.
   */
  export interface TransactionResponseParams {
    /**
     *  The block number of the block that included this transaction.
     */
    blockNumber: null | number;
    /**
     *  The block hash of the block that included this transaction.
     */
    blockHash: null | string;
    /**
     *  The transaction hash.
     */
    hash: string;
    /**
     *  The transaction index.
     */
    index: number;
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    type: number;
    /**
     *  The target of the transaction. If ``null``, the ``data`` is initcode
     *  and this transaction is a deployment transaction.
     */
    to: null | string;
    /**
     *  The sender of the transaction.
     */
    from: string;
    /**
     *  The nonce of the transaction, used for replay protection.
     */
    nonce: number;
    /**
     *  The maximum amount of gas this transaction is authorized to consume.
     */
    gasLimit: bigint;
    /**
     *  For legacy transactions, this is the gas price per gas to pay.
     */
    gasPrice: bigint;
    /**
     *  For [[link-eip-1559]] transactions, this is the maximum priority
     *  fee to allow a producer to claim.
     */
    maxPriorityFeePerGas: null | bigint;
    /**
     *  For [[link-eip-1559]] transactions, this is the maximum fee that
     *  will be paid.
     */
    maxFeePerGas: null | bigint;
    /**
     *  The transaction data.
     */
    data: string;
    /**
     *  The transaction value (in wei).
     */
    value: bigint;
    /**
     *  The chain ID this transaction is valid on.
     */
    chainId: bigint;
    /**
     *  The signature of the transaction.
     */
    signature: Signature;
    /**
     *  The transaction access list.
     */
    accessList: null | AccessList;
  }
  /**
   *  A **BlockTag** specifies a specific block.
   *
   *  **numeric value** - specifies the block height, where
   *  the genesis block is block 0; many operations accept a negative
   *  value which indicates the block number should be deducted from
   *  the most recent block. A numeric value may be a ``number``, ``bigint``,
   *  or a decimal of hex string.
   *
   *  **blockhash** - specifies a specific block by its blockhash; this allows
   *  potentially orphaned blocks to be specifed, without ambiguity, but many
   *  backends do not support this for some operations.
   */
  export type BlockTag = BigNumberish | string;
  /**
   *  A **FeeData** wraps all the fee-related values associated with
   *  the network.
   */
  export declare class FeeData {
    /**
     *  The gas price for legacy networks.
     */
    readonly gasPrice: null | bigint;
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    readonly maxFeePerGas: null | bigint;
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    readonly maxPriorityFeePerGas: null | bigint;
    /**
     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
     *  %%maxPriorityFeePerGas%%.
     */
    constructor(
      gasPrice?: null | bigint,
      maxFeePerGas?: null | bigint,
      maxPriorityFeePerGas?: null | bigint
    );
    /**
     *  Returns a JSON-friendly value.
     */
    toJSON(): any;
  }
  /**
   *  A **TransactionRequest** is a transactions with potentially various
   *  properties not defined, or with less strict types for its values.
   *
   *  This is used to pass to various operations, which will internally
   *  coerce any types and populate any necessary values.
   */
  export interface TransactionRequest {
    /**
     *  The transaction type.
     */
    type?: null | number;
    /**
     *  The target of the transaction.
     */
    to?: null | AddressLike;
    /**
     *  The sender of the transaction.
     */
    from?: null | AddressLike;
    /**
     *  The nonce of the transaction, used to prevent replay attacks.
     */
    nonce?: null | number;
    /**
     *  The maximum amount of gas to allow this transaction to consime.
     */
    gasLimit?: null | BigNumberish;
    /**
     *  The gas price to use for legacy transactions or transactions on
     *  legacy networks.
     *
     *  Most of the time the ``max*FeePerGas`` is preferred.
     */
    gasPrice?: null | BigNumberish;
    /**
     *  The [[link-eip-1559]] maximum priority fee to pay per gas.
     */
    maxPriorityFeePerGas?: null | BigNumberish;
    /**
     *  The [[link-eip-1559]] maximum total fee to pay per gas. The actual
     *  value used is protocol enforced to be the block's base fee.
     */
    maxFeePerGas?: null | BigNumberish;
    /**
     *  The transaction data.
     */
    data?: null | string;
    /**
     *  The transaction value (in wei).
     */
    value?: null | BigNumberish;
    /**
     *  The chain ID for the network this transaction is valid on.
     */
    chainId?: null | BigNumberish;
    /**
     *  The [[link-eip-2930]] access list. Storage slots included in the access
     *  list are //warmed// by pre-loading them, so their initial cost to
     *  fetch is guaranteed, but then each additional access is cheaper.
     */
    accessList?: null | AccessListish;
    /**
     *  A custom object, which can be passed along for network-specific
     *  values.
     */
    customData?: any;
    /**
     *  When using ``call`` or ``estimateGas``, this allows a specific
     *  block to be queried. Many backends do not support this and when
     *  unsupported errors are silently squelched and ``"latest"`` is used.
     */
    blockTag?: BlockTag;
    /**
     *  When using ``call``, this enables CCIP-read, which permits the
     *  provider to be redirected to web-based content during execution,
     *  which is then further validated by the contract.
     *
     *  There are potential security implications allowing CCIP-read, as
     *  it could be used to expose the IP address or user activity during
     *  the fetch to unexpected parties.
     */
    enableCcipRead?: boolean;
  }
  /**
   *  A **PreparedTransactionRequest** is identical to a [[TransactionRequest]]
   *  except all the property types are strictly enforced.
   */
  export interface PreparedTransactionRequest {
    /**
     *  The transaction type.
     */
    type?: number;
    /**
     *  The target of the transaction.
     */
    to?: AddressLike;
    /**
     *  The sender of the transaction.
     */
    from?: AddressLike;
    /**
     *  The nonce of the transaction, used to prevent replay attacks.
     */
    nonce?: number;
    /**
     *  The maximum amount of gas to allow this transaction to consime.
     */
    gasLimit?: bigint;
    /**
     *  The gas price to use for legacy transactions or transactions on
     *  legacy networks.
     *
     *  Most of the time the ``max*FeePerGas`` is preferred.
     */
    gasPrice?: bigint;
    /**
     *  The [[link-eip-1559]] maximum priority fee to pay per gas.
     */
    maxPriorityFeePerGas?: bigint;
    /**
     *  The [[link-eip-1559]] maximum total fee to pay per gas. The actual
     *  value used is protocol enforced to be the block's base fee.
     */
    maxFeePerGas?: bigint;
    /**
     *  The transaction data.
     */
    data?: string;
    /**
     *  The transaction value (in wei).
     */
    value?: bigint;
    /**
     *  The chain ID for the network this transaction is valid on.
     */
    chainId?: bigint;
    /**
     *  The [[link-eip-2930]] access list. Storage slots included in the access
     *  list are //warmed// by pre-loading them, so their initial cost to
     *  fetch is guaranteed, but then each additional access is cheaper.
     */
    accessList?: AccessList;
    /**
     *  A custom object, which can be passed along for network-specific
     *  values.
     */
    customData?: any;
    /**
     *  When using ``call`` or ``estimateGas``, this allows a specific
     *  block to be queried. Many backends do not support this and when
     *  unsupported errors are silently squelched and ``"latest"`` is used.
     */
    blockTag?: BlockTag;
    /**
     *  When using ``call``, this enables CCIP-read, which permits the
     *  provider to be redirected to web-based content during execution,
     *  which is then further validated by the contract.
     *
     *  There are potential security implications allowing CCIP-read, as
     *  it could be used to expose the IP address or user activity during
     *  the fetch to unexpected parties.
     */
    enableCcipRead?: boolean;
  }
  /**
   *  Returns a copy of %%req%% with all properties coerced to their strict
   *  types.
   */
  export declare function copyRequest(
    req: TransactionRequest
  ): PreparedTransactionRequest;
  /**
   *  An Interface to indicate a [[Block]] has been included in the
   *  blockchain. This asserts a Type Guard that necessary properties
   *  are non-null.
   *
   *  Before a block is included, it is a //pending// block.
   */
  export interface MinedBlock extends Block {
    /**
     *  The block number also known as the block height.
     */
    readonly number: number;
    /**
     *  The block hash.
     */
    readonly hash: string;
    /**
     *  The block timestamp, in seconds from epoch.
     */
    readonly timestamp: number;
    /**
     *  The block date, created from the [[timestamp]].
     */
    readonly date: Date;
    /**
     *  The miner of the block, also known as the ``author`` or
     *  block ``producer``.
     */
    readonly miner: string;
  }
  /**
   *  A **Block** represents the data associated with a full block on
   *  Ethereum.
   */
  export declare class Block implements BlockParams, Iterable<string> {
    #private;
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    readonly provider: Provider;
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    readonly number: number;
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    readonly hash: null | string;
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    readonly timestamp: number;
    /**
     *  The block hash of the parent block.
     */
    readonly parentHash: string;
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    readonly nonce: string;
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    readonly difficulty: bigint;
    /**
     *  The total gas limit for this block.
     */
    readonly gasLimit: bigint;
    /**
     *  The total gas used in this block.
     */
    readonly gasUsed: bigint;
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    readonly miner: string;
    /**
     *  Any extra data the validator wished to include.
     */
    readonly extraData: string;
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    readonly baseFeePerGas: null | bigint;
    /**
     *  Create a new **Block** object.
     *
     *  This should generally not be necessary as the unless implementing a
     *  low-level library.
     */
    constructor(block: BlockParams, provider: Provider);
    /**
     *  Returns the list of transaction hashes.
     */
    get transactions(): ReadonlyArray<string>;
    /**
     *  Returns the complete transactions for blocks which
     *  prefetched them, by passing ``true`` to %%prefetchTxs%%
     *  into [[Provider-getBlock]].
     */
    get prefetchedTransactions(): Array<TransactionResponse>;
    /**
     *  Returns a JSON-friendly value.
     */
    toJSON(): any;
    [Symbol.iterator](): Iterator<string>;
    /**
     *  The number of transactions in this block.
     */
    get length(): number;
    /**
     *  The [[link-js-date]] this block was included at.
     */
    get date(): null | Date;
    /**
     *  Get the transaction at %%indexe%% within this block.
     */
    getTransaction(indexOrHash: number | string): Promise<TransactionResponse>;
    /**
     *  If a **Block** was fetched with a request to include the transactions
     *  this will allow synchronous access to those transactions.
     *
     *  If the transactions were not prefetched, this will throw.
     */
    getPrefetchedTransaction(indexOrHash: number | string): TransactionResponse;
    /**
     *  Returns true if this block been mined. This provides a type guard
     *  for all properties on a [[MinedBlock]].
     */
    isMined(): this is MinedBlock;
    /**
     *  Returns true if this block is an [[link-eip-2930]] block.
     */
    isLondon(): this is Block & {
      baseFeePerGas: bigint;
    };
    /**
     *  @_ignore:
     */
    orphanedEvent(): OrphanFilter;
  }
  /**
   *  A **Log** in Ethereum represents an event that has been included in a
   *  transaction using the ``LOG*`` opcodes, which are most commonly used by
   *  Solidity's emit for announcing events.
   */
  export declare class Log implements LogParams {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    readonly provider: Provider;
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    readonly transactionHash: string;
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    readonly blockHash: string;
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    readonly blockNumber: number;
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    readonly removed: boolean;
    /**
     *  The address of the contract that emitted this log.
     */
    readonly address: string;
    /**
     *  The data included in this log when it was emitted.
     */
    readonly data: string;
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    readonly topics: ReadonlyArray<string>;
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    readonly index: number;
    /**
     *  The index within the transaction of this log.
     */
    readonly transactionIndex: number;
    /**
     *  @_ignore:
     */
    constructor(log: LogParams, provider: Provider);
    /**
     *  Returns a JSON-compatible object.
     */
    toJSON(): any;
    /**
     *  Returns the block that this log occurred in.
     */
    getBlock(): Promise<Block>;
    /**
     *  Returns the transaction that this log occurred in.
     */
    getTransaction(): Promise<TransactionResponse>;
    /**
     *  Returns the transaction receipt fot the transaction that this
     *  log occurred in.
     */
    getTransactionReceipt(): Promise<TransactionReceipt>;
    /**
     *  @_ignore:
     */
    removedEvent(): OrphanFilter;
  }
  /**
   *  A **TransactionReceipt** includes additional information about a
   *  transaction that is only available after it has been mined.
   */
  export declare class TransactionReceipt
    implements TransactionReceiptParams, Iterable<Log>
  {
    #private;
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    readonly provider: Provider;
    /**
     *  The address the transaction was send to.
     */
    readonly to: null | string;
    /**
     *  The sender of the transaction.
     */
    readonly from: string;
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    readonly contractAddress: null | string;
    /**
     *  The transaction hash.
     */
    readonly hash: string;
    /**
     *  The index of this transaction within the block transactions.
     */
    readonly index: number;
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    readonly blockHash: string;
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    readonly blockNumber: number;
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    readonly logsBloom: string;
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    readonly gasUsed: bigint;
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    readonly cumulativeGasUsed: bigint;
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    readonly gasPrice: bigint;
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    readonly type: number;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    readonly status: null | number;
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    readonly root: null | string;
    /**
     *  @_ignore:
     */
    constructor(tx: TransactionReceiptParams, provider: Provider);
    /**
     *  The logs for this transaction.
     */
    get logs(): ReadonlyArray<Log>;
    /**
     *  Returns a JSON-compatible representation.
     */
    toJSON(): any;
    /**
     *  @_ignore:
     */
    get length(): number;
    [Symbol.iterator](): Iterator<Log>;
    /**
     *  The total fee for this transaction, in wei.
     */
    get fee(): bigint;
    /**
     *  Resolves to the block this transaction occurred in.
     */
    getBlock(): Promise<Block>;
    /**
     *  Resolves to the transaction this transaction occurred in.
     */
    getTransaction(): Promise<TransactionResponse>;
    /**
     *  Resolves to the return value of the execution of this transaction.
     *
     *  Support for this feature is limited, as it requires an archive node
     *  with the ``debug_`` or ``trace_`` API enabled.
     */
    getResult(): Promise<string>;
    /**
     *  Resolves to the number of confirmations this transaction has.
     */
    confirmations(): Promise<number>;
    /**
     *  @_ignore:
     */
    removedEvent(): OrphanFilter;
    /**
     *  @_ignore:
     */
    reorderedEvent(other?: TransactionResponse): OrphanFilter;
  }
  /**
   *  A **MinedTransactionResponse** is an interface representing a
   *  transaction which has been mined and allows for a type guard for its
   *  property values being defined.
   */
  export interface MinedTransactionResponse extends TransactionResponse {
    /**
     *  The block number this transaction occurred in.
     */
    blockNumber: number;
    /**
     *  The block hash this transaction occurred in.
     */
    blockHash: string;
    /**
     *  The date this transaction occurred on.
     */
    date: Date;
  }
  /**
   *  A **TransactionResponse** includes all properties about a transaction
   *  that was sent to the network, which may or may not be included in a
   *  block.
   *
   *  The [[TransactionResponse-isMined]] can be used to check if the
   *  transaction has been mined as well as type guard that the otherwise
   *  possibly ``null`` properties are defined.
   */
  export declare class TransactionResponse
    implements TransactionLike<string>, TransactionResponseParams
  {
    #private;
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    readonly provider: Provider;
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    readonly blockNumber: null | number;
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    readonly blockHash: null | string;
    /**
     *  The index within the block that this transaction resides at.
     */
    readonly index: number;
    /**
     *  The transaction hash.
     */
    readonly hash: string;
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    readonly type: number;
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    readonly to: null | string;
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    readonly from: string;
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    readonly nonce: number;
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    readonly gasLimit: bigint;
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    readonly gasPrice: bigint;
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    readonly maxPriorityFeePerGas: null | bigint;
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    readonly maxFeePerGas: null | bigint;
    /**
     *  The data.
     */
    readonly data: string;
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    readonly value: bigint;
    /**
     *  The chain ID.
     */
    readonly chainId: bigint;
    /**
     *  The signature.
     */
    readonly signature: Signature;
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    readonly accessList: null | AccessList;
    /**
     *  @_ignore:
     */
    constructor(tx: TransactionResponseParams, provider: Provider);
    /**
     *  Returns a JSON-compatible representation of this transaction.
     */
    toJSON(): any;
    /**
     *  Resolves to the Block that this transaction was included in.
     *
     *  This will return null if the transaction has not been included yet.
     */
    getBlock(): Promise<null | Block>;
    /**
     *  Resolves to this transaction being re-requested from the
     *  provider. This can be used if you have an unmined transaction
     *  and wish to get an up-to-date populated instance.
     */
    getTransaction(): Promise<null | TransactionResponse>;
    /**
     *  Resolve to the number of confirmations this transaction has.
     */
    confirmations(): Promise<number>;
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    wait(
      _confirms?: number,
      _timeout?: number
    ): Promise<null | TransactionReceipt>;
    /**
     *  Returns ``true`` if this transaction has been included.
     *
     *  This is effective only as of the time the TransactionResponse
     *  was instantiated. To get up-to-date information, use
     *  [[getTransaction]].
     *
     *  This provides a Type Guard that this transaction will have
     *  non-null property values for properties that are null for
     *  unmined transactions.
     */
    isMined(): this is MinedTransactionResponse;
    /**
     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
     *  transaction.
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLegacy(): this is TransactionResponse & {
      accessList: null;
      maxFeePerGas: null;
      maxPriorityFeePerGas: null;
    };
    /**
     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
     *  transaction. See [[link-eip-2070]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isBerlin(): this is TransactionResponse & {
      accessList: AccessList;
      maxFeePerGas: null;
      maxPriorityFeePerGas: null;
    };
    /**
     *  Returns true if the transaction is a London (i.e. ``type == 2``)
     *  transaction. See [[link-eip-1559]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
    isLondon(): this is TransactionResponse & {
      accessList: AccessList;
      maxFeePerGas: bigint;
      maxPriorityFeePerGas: bigint;
    };
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that evict this transaction.
     */
    removedEvent(): OrphanFilter;
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that re-order this event against %%other%%.
     */
    reorderedEvent(other?: TransactionResponse): OrphanFilter;
    /**
     *  Returns a new TransactionResponse instance which has the ability to
     *  detect (and throw an error) if the transaction is replaced, which
     *  will begin scanning at %%startBlock%%.
     *
     *  This should generally not be used by developers and is intended
     *  primarily for internal use. Setting an incorrect %%startBlock%% can
     *  have devastating performance consequences if used incorrectly.
     */
    replaceableTransaction(startBlock: number): TransactionResponse;
  }
  /**
   *  An Orphan Filter allows detecting when an orphan block has
   *  resulted in dropping a block or transaction or has resulted
   *  in transactions changing order.
   *
   *  Not currently fully supported.
   */
  export type OrphanFilter =
    | {
        orphan: "drop-block";
        hash: string;
        number: number;
      }
    | {
        orphan: "drop-transaction";
        tx: {
          hash: string;
          blockHash: string;
          blockNumber: number;
        };
        other?: {
          hash: string;
          blockHash: string;
          blockNumber: number;
        };
      }
    | {
        orphan: "reorder-transaction";
        tx: {
          hash: string;
          blockHash: string;
          blockNumber: number;
        };
        other?: {
          hash: string;
          blockHash: string;
          blockNumber: number;
        };
      }
    | {
        orphan: "drop-log";
        log: {
          transactionHash: string;
          blockHash: string;
          blockNumber: number;
          address: string;
          data: string;
          topics: ReadonlyArray<string>;
          index: number;
        };
      };
  /**
   *  A **TopicFilter** provides a struture to define bloom-filter
   *  queries.
   *
   *  Each field that is ``null`` matches **any** value, a field that is
   *  a ``string`` must match exactly that value and and ``array`` is
   *  effectively an ``OR``-ed set, where any one of those values must
   *  match.
   */
  export type TopicFilter = Array<null | string | Array<string>>;
  /**
   *  An **EventFilter** allows efficiently filtering logs (also known as
   *  events) using bloom filters included within blocks.
   */
  export interface EventFilter {
    address?: AddressLike | Array<AddressLike>;
    topics?: TopicFilter;
  }
  /**
   *  A **Filter** allows searching a specific range of blocks for mathcing
   *  logs.
   */
  export interface Filter extends EventFilter {
    /**
     *  The start block for the filter (inclusive).
     */
    fromBlock?: BlockTag;
    /**
     *  The end block for the filter (inclusive).
     */
    toBlock?: BlockTag;
  }
  /**
   *  A **FilterByBlockHash** allows searching a specific block for mathcing
   *  logs.
   */
  export interface FilterByBlockHash extends EventFilter {
    /**
     *  The blockhash of the specific block for the filter.
     */
    blockHash?: string;
  }
  /**
   *  A **ProviderEvent** provides the types of events that can be subscribed
   *  to on a [[Provider]].
   *
   *  Each provider may include additional possible events it supports, but
   *  the most commonly supported are:
   *
   *  **``"block"``** - calls the listener with the current block number on each
   *  new block.
   *
   *  **``"error"``** - calls the listener on each async error that occurs during
   *  the event loop, with the error.
   *
   *  **``"debug"``** - calls the listener on debug events, which can be used to
   *  troubleshoot network errors, provider problems, etc.
   *
   *  **``transaction hash``** - calls the listener on each block after the
   *  transaction has been mined; generally ``.once`` is more appropriate for
   *  this event.
   *
   *  **``Array``** - calls the listener on each log that matches the filter.
   *
   *  [[EventFilter]] - calls the listener with each matching log
   */
  export type ProviderEvent =
    | string
    | Array<string | Array<string>>
    | EventFilter
    | OrphanFilter;
  /**
   *  A **Provider** is the primary method to interact with the read-only
   *  content on Ethereum.
   *
   *  It allows access to details about accounts, blocks and transactions
   *  and the ability to query event logs and simulate contract execution.
   *
   *  Account data includes the [balance](getBalance),
   *  [transaction count](getTransactionCount), [code](getCode) and
   *  [state trie storage](getStorage).
   *
   *  Simulating execution can be used to [call](call),
   *  [estimate gas](estimateGas) and
   *  [get transaction results](getTransactionResult).
   *
   *  The [[broadcastTransaction]] is the only method which allows updating
   *  the blockchain, but it is usually accessed by a [[Signer]], since a
   *  private key must be used to sign the transaction before it can be
   *  broadcast.
   */
  export interface Provider
    extends ContractRunner,
      EventEmitterable<ProviderEvent>,
      NameResolver {
    /**
     *  The provider iteself.
     *
     *  This is part of the necessary API for executing a contract, as
     *  it provides a common property on any [[ContractRunner]] that
     *  can be used to access the read-only portion of the runner.
     */
    provider: this;
    /**
     *  Shutdown any resources this provider is using. No additional
     *  calls should be made to this provider after calling this.
     */
    destroy(): void;
    /**
     *  Get the current block number.
     */
    getBlockNumber(): Promise<number>;
    /**
     *  Get the connected [[Network]].
     */
    getNetwork(): Promise<Network>;
    /**
     *  Get the best guess at the recommended [[FeeData]].
     */
    getFeeData(): Promise<FeeData>;
    /**
     *  Get the account balance (in wei) of %%address%%. If %%blockTag%%
     *  is specified and the node supports archive access for that
     *  %%blockTag%%, the balance is as of that [[BlockTag]].
     *
     *  @note On nodes without archive access enabled, the %%blockTag%% may be
     *        **silently ignored** by the node, which may cause issues if relied on.
     */
    getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint>;
    /**
     *  Get the number of transactions ever sent for %%address%%, which
     *  is used as the ``nonce`` when sending a transaction. If
     *  %%blockTag%% is specified and the node supports archive access
     *  for that %%blockTag%%, the transaction count is as of that
     *  [[BlockTag]].
     *
     *  @note On nodes without archive access enabled, the %%blockTag%% may be
     *        **silently ignored** by the node, which may cause issues if relied on.
     */
    getTransactionCount(
      address: AddressLike,
      blockTag?: BlockTag
    ): Promise<number>;
    /**
     *  Get the bytecode for %%address%%.
     *
     *  @note On nodes without archive access enabled, the %%blockTag%% may be
     *        **silently ignored** by the node, which may cause issues if relied on.
     */
    getCode(address: AddressLike, blockTag?: BlockTag): Promise<string>;
    /**
     *  Get the storage slot value for %%address%% at slot %%position%%.
     *
     *  @note On nodes without archive access enabled, the %%blockTag%% may be
     *        **silently ignored** by the node, which may cause issues if relied on.
     */
    getStorage(
      address: AddressLike,
      position: BigNumberish,
      blockTag?: BlockTag
    ): Promise<string>;
    /**
     *  Estimates the amount of gas required to executre %%tx%%.
     */
    estimateGas(tx: TransactionRequest): Promise<bigint>;
    /**
     *  Simulate the execution of %%tx%%. If the call reverts, it will
     *  throw a [[CallExceptionError]] which includes the revert data.
     */
    call(tx: TransactionRequest): Promise<string>;
    /**
     *  Broadcasts the %%signedTx%% to the network, adding it to the
     *  memory pool of any node for which the transaction meets the
     *  rebroadcast requirements.
     */
    broadcastTransaction(signedTx: string): Promise<TransactionResponse>;
    /**
     *  Resolves to the block for %%blockHashOrBlockTag%%.
     *
     *  If %%prefetchTxs%%, and the backend supports including transactions
     *  with block requests, all transactions will be included and the
     *  [[Block]] object will not need to make remote calls for getting
     *  transactions.
     */
    getBlock(
      blockHashOrBlockTag: BlockTag | string,
      prefetchTxs?: boolean
    ): Promise<null | Block>;
    /**
     *  Resolves to the transaction for %%hash%%.
     *
     *  If the transaction is unknown or on pruning nodes which
     *  discard old transactions this resolves to ``null``.
     */
    getTransaction(hash: string): Promise<null | TransactionResponse>;
    /**
     *  Resolves to the transaction receipt for %%hash%%, if mined.
     *
     *  If the transaction has not been mined, is unknown or on
     *  pruning nodes which discard old transactions this resolves to
     *  ``null``.
     */
    getTransactionReceipt(hash: string): Promise<null | TransactionReceipt>;
    /**
     *  Resolves to the result returned by the executions of %%hash%%.
     *
     *  This is only supported on nodes with archive access and with
     *  the necessary debug APIs enabled.
     */
    getTransactionResult(hash: string): Promise<null | string>;
    /**
     *  Resolves to the list of Logs that match %%filter%%
     */
    getLogs(filter: Filter | FilterByBlockHash): Promise<Array<Log>>;
    /**
     *  Resolves to the address configured for the %%ensName%% or
     *  ``null`` if unconfigured.
     */
    resolveName(ensName: string): Promise<null | string>;
    /**
     *  Resolves to the ENS name associated for the %%address%% or
     *  ``null`` if the //primary name// is not configured.
     *
     *  Users must perform additional steps to configure a //primary name//,
     *  which is not currently common.
     */
    lookupAddress(address: string): Promise<null | string>;
    /**
     *  Waits until the transaction %%hash%% is mined and has %%confirms%%
     *  confirmations.
     */
    waitForTransaction(
      hash: string,
      confirms?: number,
      timeout?: number
    ): Promise<null | TransactionReceipt>;
    /**
     *  Resolves to the block at %%blockTag%% once it has been mined.
     *
     *  This can be useful for waiting some number of blocks by using
     *  the ``currentBlockNumber + N``.
     */
    waitForBlock(blockTag?: BlockTag): Promise<Block>;
  }
  /**
   *  The type of data found during a steip during avatar resolution.
   */
  export type AvatarLinkageType =
    | "name"
    | "avatar"
    | "!avatar"
    | "url"
    | "data"
    | "ipfs"
    | "erc721"
    | "erc1155"
    | "!erc721-caip"
    | "!erc1155-caip"
    | "!owner"
    | "owner"
    | "!balance"
    | "balance"
    | "metadata-url-base"
    | "metadata-url-expanded"
    | "metadata-url"
    | "!metadata-url"
    | "!metadata"
    | "metadata"
    | "!imageUrl"
    | "imageUrl-ipfs"
    | "imageUrl"
    | "!imageUrl-ipfs";
  /**
   *  An individual record for each step during avatar resolution.
   */
  export interface AvatarLinkage {
    /**
     *  The type of linkage.
     */
    type: AvatarLinkageType;
    /**
     *  The linkage value.
     */
    value: string;
  }
  /**
   *  When resolving an avatar for an ENS name, there are many
   *  steps involved, fetching metadata, validating results, et cetera.
   *
   *  Some applications may wish to analyse this data, or use this data
   *  to diagnose promblems, so an **AvatarResult** provides details of
   *  each completed step during avatar resolution.
   */
  export interface AvatarResult {
    /**
     *  How the [[url]] was arrived at, resolving the many steps required
     *  for an avatar URL.
     */
    linkage: Array<AvatarLinkage>;
    /**
     *  The avatar URL or null if the avatar was not set, or there was
     *  an issue during validation (such as the address not owning the
     *  avatar or a metadata error).
     */
    url: null | string;
  }
  /**
   *  A provider plugin super-class for processing multicoin address types.
   */
  export declare abstract class MulticoinProviderPlugin
    implements AbstractProviderPlugin
  {
    /**
     *  The name.
     */
    readonly name: string;
    /**
     *  Creates a new **MulticoinProviderPluing** for %%name%%.
     */
    constructor(name: string);
    connect(proivder: Provider): MulticoinProviderPlugin;
    /**
     *  Returns ``true`` if %%coinType%% is supported by this plugin.
     */
    supportsCoinType(coinType: number): boolean;
    /**
     *  Resovles to the encoded %%address%% for %%coinType%%.
     */
    encodeAddress(coinType: number, address: string): Promise<string>;
    /**
     *  Resovles to the decoded %%data%% for %%coinType%%.
     */
    decodeAddress(coinType: number, data: BytesLike): Promise<string>;
  }
  /**
   *  A connected object to a resolved ENS name resolver, which can be
   *  used to query additional details.
   */
  export declare class EnsResolver {
    #private;
    /**
     *  The connected provider.
     */
    provider: AbstractProvider;
    /**
     *  The address of the resolver.
     */
    address: string;
    /**
     *  The name this resolver was resolved against.
     */
    name: string;
    constructor(provider: AbstractProvider, address: string, name: string);
    /**
     *  Resolves to true if the resolver supports wildcard resolution.
     */
    supportsWildcard(): Promise<boolean>;
    /**
     *  Resolves to the address for %%coinType%% or null if the
     *  provided %%coinType%% has not been configured.
     */
    getAddress(coinType?: number): Promise<null | string>;
    /**
     *  Resolves to the EIP-634 text record for %%key%%, or ``null``
     *  if unconfigured.
     */
    getText(key: string): Promise<null | string>;
    /**
     *  Rsolves to the content-hash or ``null`` if unconfigured.
     */
    getContentHash(): Promise<null | string>;
    /**
     *  Resolves to the avatar url or ``null`` if the avatar is either
     *  unconfigured or incorrectly configured (e.g. references an NFT
     *  not owned by the address).
     *
     *  If diagnosing issues with configurations, the [[_getAvatar]]
     *  method may be useful.
     */
    getAvatar(): Promise<null | string>;
    /**
     *  When resolving an avatar, there are many steps involved, such
     *  fetching metadata and possibly validating ownership of an
     *  NFT.
     *
     *  This method can be used to examine each step and the value it
     *  was working from.
     */
    _getAvatar(): Promise<AvatarResult>;
    static getEnsAddress(provider: Provider): Promise<string>;
    /**
     *  Resolve to the ENS resolver for %%name%% using %%provider%% or
     *  ``null`` if unconfigured.
     */
    static fromName(
      provider: AbstractProvider,
      name: string
    ): Promise<null | EnsResolver>;
  }
  /**
   *  The value passed to the [[AbstractProvider-_getSubscriber]] method.
   *
   *  Only developers sub-classing [[AbstractProvider[[ will care about this,
   *  if they are modifying a low-level feature of how subscriptions operate.
   */
  export type Subscription =
    | {
        type: "block" | "close" | "debug" | "error" | "network" | "pending";
        tag: string;
      }
    | {
        type: "transaction";
        tag: string;
        hash: string;
      }
    | {
        type: "event";
        tag: string;
        filter: EventFilter;
      }
    | {
        type: "orphan";
        tag: string;
        filter: OrphanFilter;
      };
  /**
   *  A **Subscriber** manages a subscription.
   *
   *  Only developers sub-classing [[AbstractProvider[[ will care about this,
   *  if they are modifying a low-level feature of how subscriptions operate.
   */
  export interface Subscriber {
    /**
     *  Called initially when a subscriber is added the first time.
     */
    start(): void;
    /**
     *  Called when there are no more subscribers to the event.
     */
    stop(): void;
    /**
     *  Called when the subscription should pause.
     *
     *  If %%dropWhilePaused%%, events that occur while paused should not
     *  be emitted [[resume]].
     */
    pause(dropWhilePaused?: boolean): void;
    /**
     *  Resume a paused subscriber.
     */
    resume(): void;
    /**
     *  The frequency (in ms) to poll for events, if polling is used by
     *  the subscriber.
     *
     *  For non-polling subscribers, this must return ``undefined``.
     */
    pollingInterval?: number;
  }
  /**
   *  An **UnmanagedSubscriber** is useful for events which do not require
   *  any additional management, such as ``"debug"`` which only requires
   *  emit in synchronous event loop triggered calls.
   */
  export declare class UnmanagedSubscriber implements Subscriber {
    /**
     *  The name fof the event.
     */
    name: string;
    /**
     *  Create a new UnmanagedSubscriber with %%name%%.
     */
    constructor(name: string);
    start(): void;
    stop(): void;
    pause(dropWhilePaused?: boolean): void;
    resume(): void;
  }
  /**
   *  An **AbstractPlugin** is used to provide additional internal services
   *  to an [[AbstractProvider]] without adding backwards-incompatible changes
   *  to method signatures or other internal and complex logic.
   */
  export interface AbstractProviderPlugin {
    /**
     *  The reverse domain notation of the plugin.
     */
    readonly name: string;
    /**
     *  Creates a new instance of the plugin, connected to %%provider%%.
     */
    connect(provider: AbstractProvider): AbstractProviderPlugin;
  }
  /**
   *  A normalized filter used for [[PerformActionRequest]] objects.
   */
  export type PerformActionFilter =
    | {
        address?: string | Array<string>;
        topics?: Array<null | string | Array<string>>;
        fromBlock?: BlockTag;
        toBlock?: BlockTag;
      }
    | {
        address?: string | Array<string>;
        topics?: Array<null | string | Array<string>>;
        blockHash?: string;
      };
  /**
   *  A normalized transactions used for [[PerformActionRequest]] objects.
   */
  export interface PerformActionTransaction extends PreparedTransactionRequest {
    /**
     *  The ``to`` address of the transaction.
     */
    to?: string;
    /**
     *  The sender of the transaction.
     */
    from?: string;
  }
  /**
   *  The [[AbstractProvider]] methods will normalize all values and pass this
   *  type to [[AbstractProvider-_perform]].
   */
  export type PerformActionRequest =
    | {
        method: "broadcastTransaction";
        signedTransaction: string;
      }
    | {
        method: "call";
        transaction: PerformActionTransaction;
        blockTag: BlockTag;
      }
    | {
        method: "chainId";
      }
    | {
        method: "estimateGas";
        transaction: PerformActionTransaction;
      }
    | {
        method: "getBalance";
        address: string;
        blockTag: BlockTag;
      }
    | {
        method: "getBlock";
        blockTag: BlockTag;
        includeTransactions: boolean;
      }
    | {
        method: "getBlock";
        blockHash: string;
        includeTransactions: boolean;
      }
    | {
        method: "getBlockNumber";
      }
    | {
        method: "getCode";
        address: string;
        blockTag: BlockTag;
      }
    | {
        method: "getGasPrice";
      }
    | {
        method: "getLogs";
        filter: PerformActionFilter;
      }
    | {
        method: "getStorage";
        address: string;
        position: bigint;
        blockTag: BlockTag;
      }
    | {
        method: "getTransaction";
        hash: string;
      }
    | {
        method: "getTransactionCount";
        address: string;
        blockTag: BlockTag;
      }
    | {
        method: "getTransactionReceipt";
        hash: string;
      }
    | {
        method: "getTransactionResult";
        hash: string;
      };
  /**
   *  Options for configuring some internal aspects of an [[AbstractProvider]].
   *
   *  **``cacheTimeout``** - how long to cache a low-level ``_perform``
   *  for, based on input parameters. This reduces the number of calls
   *  to getChainId and getBlockNumber, but may break test chains which
   *  can perform operations (internally) synchronously. Use ``-1`` to
   *  disable, ``0`` will only buffer within the same event loop and
   *  any other value is in ms. (default: ``250``)
   */
  export type AbstractProviderOptions = {
    cacheTimeout?: number;
  };
  /**
   *  An **AbstractProvider** provides a base class for other sub-classes to
   *  implement the [[Provider]] API by normalizing input arguments and
   *  formatting output results as well as tracking events for consistent
   *  behaviour on an eventually-consistent network.
   */
  export declare class AbstractProvider implements Provider {
    #private;
    /**
     *  Create a new **AbstractProvider** connected to %%network%%, or
     *  use the various network detection capabilities to discover the
     *  [[Network]] if necessary.
     */
    constructor(
      _network?: "any" | Networkish,
      options?: AbstractProviderOptions
    );
    /**
     *  Returns ``this``, to allow an **AbstractProvider** to implement
     *  the [[ContractRunner]] interface.
     */
    get provider(): this;
    /**
     *  Returns all the registered plug-ins.
     */
    get plugins(): Array<AbstractProviderPlugin>;
    /**
     *  Attach a new plug-in.
     */
    attachPlugin(plugin: AbstractProviderPlugin): this;
    /**
     *  Get a plugin by name.
     */
    getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(
      name: string
    ): null | T;
    /**
     *  Prevent any CCIP-read operation, regardless of whether requested
     *  in a [[call]] using ``enableCcipRead``.
     */
    get disableCcipRead(): boolean;
    set disableCcipRead(value: boolean);
    /**
     *  Resolves to the data for executing the CCIP-read operations.
     */
    ccipReadFetch(
      tx: PerformActionTransaction,
      calldata: string,
      urls: Array<string>
    ): Promise<null | string>;
    /**
     *  Provides the opportunity for a sub-class to wrap a block before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Block]].
     */
    _wrapBlock(value: BlockParams, network: Network): Block;
    /**
     *  Provides the opportunity for a sub-class to wrap a log before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Log]].
     */
    _wrapLog(value: LogParams, network: Network): Log;
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  receipt before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionReceipt]].
     */
    _wrapTransactionReceipt(
      value: TransactionReceiptParams,
      network: Network
    ): TransactionReceipt;
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  response before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionResponse]].
     */
    _wrapTransactionResponse(
      tx: TransactionResponseParams,
      network: Network
    ): TransactionResponse;
    /**
     *  Resolves to the Network, forcing a network detection using whatever
     *  technique the sub-class requires.
     *
     *  Sub-classes **must** override this.
     */
    _detectNetwork(): Promise<Network>;
    /**
     *  Sub-classes should use this to perform all built-in operations. All
     *  methods sanitizes and normalizes the values passed into this.
     *
     *  Sub-classes **must** override this.
     */
    _perform<T = any>(req: PerformActionRequest): Promise<T>;
    getBlockNumber(): Promise<number>;
    /**
     *  Returns or resolves to the address for %%address%%, resolving ENS
     *  names and [[Addressable]] objects and returning if already an
     *  address.
     */
    _getAddress(address: AddressLike): string | Promise<string>;
    /**
     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
     *  negative values and returning if already a valid block tag.
     */
    _getBlockTag(blockTag?: BlockTag): string | Promise<string>;
    /**
     *  Returns or resolves to a filter for %%filter%%, resolving any ENS
     *  names or [[Addressable]] object and returning if already a valid
     *  filter.
     */
    _getFilter(
      filter: Filter | FilterByBlockHash
    ): PerformActionFilter | Promise<PerformActionFilter>;
    /**
     *  Returns or resovles to a transaction for %%request%%, resolving
     *  any ENS names or [[Addressable]] and returning if already a valid
     *  transaction.
     */
    _getTransactionRequest(
      _request: TransactionRequest
    ): PerformActionTransaction | Promise<PerformActionTransaction>;
    getNetwork(): Promise<Network>;
    getFeeData(): Promise<FeeData>;
    estimateGas(_tx: TransactionRequest): Promise<bigint>;
    call(_tx: TransactionRequest): Promise<string>;
    getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint>;
    getTransactionCount(
      address: AddressLike,
      blockTag?: BlockTag
    ): Promise<number>;
    getCode(address: AddressLike, blockTag?: BlockTag): Promise<string>;
    getStorage(
      address: AddressLike,
      _position: BigNumberish,
      blockTag?: BlockTag
    ): Promise<string>;
    broadcastTransaction(signedTx: string): Promise<TransactionResponse>;
    getBlock(
      block: BlockTag | string,
      prefetchTxs?: boolean
    ): Promise<null | Block>;
    getTransaction(hash: string): Promise<null | TransactionResponse>;
    getTransactionReceipt(hash: string): Promise<null | TransactionReceipt>;
    getTransactionResult(hash: string): Promise<null | string>;
    getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>>;
    _getProvider(chainId: number): AbstractProvider;
    getResolver(name: string): Promise<null | EnsResolver>;
    getAvatar(name: string): Promise<null | string>;
    resolveName(name: string): Promise<null | string>;
    lookupAddress(address: string): Promise<null | string>;
    waitForTransaction(
      hash: string,
      _confirms?: null | number,
      timeout?: null | number
    ): Promise<null | TransactionReceipt>;
    waitForBlock(blockTag?: BlockTag): Promise<Block>;
    /**
     *  Clear a timer created using the [[_setTimeout]] method.
     */
    _clearTimeout(timerId: number): void;
    /**
     *  Create a timer that will execute %%func%% after at least %%timeout%%
     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
     *  in the next event loop.
     *
     *  [Pausing](AbstractProvider-paused) the provider will pause any
     *  associated timers.
     */
    _setTimeout(_func: () => void, timeout?: number): number;
    /**
     *  Perform %%func%% on each subscriber.
     */
    _forEachSubscriber(func: (s: Subscriber) => void): void;
    /**
     *  Sub-classes may override this to customize subscription
     *  implementations.
     */
    _getSubscriber(sub: Subscription): Subscriber;
    /**
     *  If a [[Subscriber]] fails and needs to replace itself, this
     *  method may be used.
     *
     *  For example, this is used for providers when using the
     *  ``eth_getFilterChanges`` method, which can return null if state
     *  filters are not supported by the backend, allowing the Subscriber
     *  to swap in a [[PollingEventSubscriber]].
     */
    _recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void;
    on(event: ProviderEvent, listener: Listener): Promise<this>;
    once(event: ProviderEvent, listener: Listener): Promise<this>;
    emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean>;
    listenerCount(event?: ProviderEvent): Promise<number>;
    listeners(event?: ProviderEvent): Promise<Array<Listener>>;
    off(event: ProviderEvent, listener?: Listener): Promise<this>;
    removeAllListeners(event?: ProviderEvent): Promise<this>;
    addListener(event: ProviderEvent, listener: Listener): Promise<this>;
    removeListener(event: ProviderEvent, listener: Listener): Promise<this>;
    /**
     *  If this provider has been destroyed using the [[destroy]] method.
     *
     *  Once destroyed, all resources are reclaimed, internal event loops
     *  and timers are cleaned up and no further requests may be sent to
     *  the provider.
     */
    get destroyed(): boolean;
    /**
     *  Sub-classes may use this to shutdown any sockets or release their
     *  resources and reject any pending requests.
     *
     *  Sub-classes **must** call ``super.destroy()``.
     */
    destroy(): void;
    /**
     *  Whether the provider is currently paused.
     *
     *  A paused provider will not emit any events, and generally should
     *  not make any requests to the network, but that is up to sub-classes
     *  to manage.
     *
     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
     *  which will buffer any events that occur while paused until the
     *  provider is unpaused.
     */
    get paused(): boolean;
    set paused(pause: boolean);
    /**
     *  Pause the provider. If %%dropWhilePaused%%, any events that occur
     *  while paused are dropped, otherwise all events will be emitted once
     *  the provider is unpaused.
     */
    pause(dropWhilePaused?: boolean): void;
    /**
     *  Resume the provider.
     */
    resume(): void;
  }
  /**
   *  A simple hashing function which operates on UTF-8 strings to
   *  compute an 32-byte identifier.
   *
   *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
   *  the [[keccak256]].
   *
   *  @example:
   *    id("hello world")
   *    //_result:
   */
  export declare function id(value: string): string;
  /**
   *  Returns the ENS %%name%% normalized.
   */
  export declare function ensNormalize(name: string): string;
  /**
   *  Returns ``true`` if %%name%% is a valid ENS name.
   */
  export declare function isValidName(name: string): name is string;
  /**
   *  Returns the [[link-namehash]] for %%name%%.
   */
  export declare function namehash(name: string): string;
  /**
   *  Returns the DNS encoded %%name%%.
   *
   *  This is used for various parts of ENS name resolution, such
   *  as the wildcard resolution.
   */
  export declare function dnsEncode(name: string): string;
  /**
   *  Computes the [[link-eip-191]] personal-sign message digest to sign.
   *
   *  This prefixes the message with [[MessagePrefix]] and the decimal length
   *  of %%message%% and computes the [[keccak256]] digest.
   *
   *  If %%message%% is a string, it is converted to its UTF-8 bytes
   *  first. To compute the digest of a [[DataHexString]], it must be converted
   *  to [bytes](getBytes).
   *
   *  @example:
   *    hashMessage("Hello World")
   *    //_result:
   *
   *    // Hashes the SIX (6) string characters, i.e.
   *    // [ "0", "x", "4", "2", "4", "3" ]
   *    hashMessage("0x4243")
   *    //_result:
   *
   *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
   *    hashMessage(getBytes("0x4243"))
   *    //_result:
   *
   *    // ...which is equal to using data
   *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))
   *    //_result:
   *
   */
  export declare function hashMessage(message: Uint8Array | string): string;
  /**
   *  Return the address of the private key that produced
   *  the signature %%sig%% during signing for %%message%%.
   */
  export declare function verifyMessage(
    message: Uint8Array | string,
    sig: SignatureLike
  ): string;
  /**
   *   Computes the [[link-solc-packed]] representation of %%values%%
   *   respectively to their %%types%%.
   *
   *   @example:
   *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
   *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
   *       //_result:
   */
  export declare function solidityPacked(
    types: ReadonlyArray<string>,
    values: ReadonlyArray<any>
  ): string;
  /**
   *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%
   *   respectively to their %%types%%.
   *
   *   @example:
   *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
   *       solidityPackedKeccak256([ "address", "uint" ], [ addr, 45 ]);
   *       //_result:
   */
  export declare function solidityPackedKeccak256(
    types: ReadonlyArray<string>,
    values: ReadonlyArray<any>
  ): string;
  /**
   *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%
   *   respectively to their %%types%%.
   *
   *   @example:
   *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
   *       solidityPackedSha256([ "address", "uint" ], [ addr, 45 ]);
   *       //_result:
   */
  export declare function solidityPackedSha256(
    types: ReadonlyArray<string>,
    values: ReadonlyArray<any>
  ): string;
  /**
   *  The domain for an [[link-eip-712]] payload.
   */
  export interface TypedDataDomain {
    /**
     *  The human-readable name of the signing domain.
     */
    name?: null | string;
    /**
     *  The major version of the signing domain.
     */
    version?: null | string;
    /**
     *  The chain ID of the signing domain.
     */
    chainId?: null | BigNumberish;
    /**
     *  The the address of the contract that will verify the signature.
     */
    verifyingContract?: null | string;
    /**
     *  A salt used for purposes decided by the specific domain.
     */
    salt?: null | BytesLike;
  }
  /**
   *  A specific field of a structured [[link-eip-712]] type.
   */
  export interface TypedDataField {
    /**
     *  The field name.
     */
    name: string;
    /**
     *  The type of the field.
     */
    type: string;
  }
  /**
   *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads
   *  for signed typed data.
   *
   *  This is useful for those that wish to compute various components of a
   *  typed data hash, primary types, or sub-components, but generally the
   *  higher level [[Signer-signTypedData]] is more useful.
   */
  export declare class TypedDataEncoder {
    #private;
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    readonly primaryType: string;
    /**
     *  The types.
     */
    get types(): Record<string, Array<TypedDataField>>;
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     *
     *  This performs all necessary checking that types are valid and
     *  do not violate the [[link-eip-712]] structural constraints as
     *  well as computes the [[primaryType]].
     */
    constructor(types: Record<string, Array<TypedDataField>>);
    /**
     *  Returnthe encoder for the specific %%type%%.
     */
    getEncoder(type: string): (value: any) => string;
    /**
     *  Return the full type for %%name%%.
     */
    encodeType(name: string): string;
    /**
     *  Return the encoded %%value%% for the %%type%%.
     */
    encodeData(type: string, value: any): string;
    /**
     *  Returns the hash of %%value%% for the type of %%name%%.
     */
    hashStruct(name: string, value: Record<string, any>): string;
    /**
     *  Return the fulled encoded %%value%% for the [[types]].
     */
    encode(value: Record<string, any>): string;
    /**
     *  Return the hash of the fully encoded %%value%% for the [[types]].
     */
    hash(value: Record<string, any>): string;
    /**
     *  @_ignore:
     */
    _visit(
      type: string,
      value: any,
      callback: (type: string, data: any) => any
    ): any;
    /**
     *  Call %%calback%% for each value in %%value%%, passing the type and
     *  component within %%value%%.
     *
     *  This is useful for replacing addresses or other transformation that
     *  may be desired on each component, based on its type.
     */
    visit(
      value: Record<string, any>,
      callback: (type: string, data: any) => any
    ): any;
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     */
    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder;
    /**
     *  Return the primary type for %%types%%.
     */
    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string;
    /**
     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
     */
    static hashStruct(
      name: string,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): string;
    /**
     *  Return the domain hash for %%domain%%.
     */
    static hashDomain(domain: TypedDataDomain): string;
    /**
     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
    static encode(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): string;
    /**
     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
    static hash(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): string;
    /**
     * Resolves to the value from resolving all addresses in %%value%% for
     * %%types%% and the %%domain%%.
     */
    static resolveNames(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>,
      resolveName: (name: string) => Promise<string>
    ): Promise<{
      domain: TypedDataDomain;
      value: any;
    }>;
    /**
     *  Returns the JSON-encoded payload expected by nodes which implement
     *  the JSON-RPC [[link-eip-712]] method.
     */
    static getPayload(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): any;
  }
  /**
   *  Compute the address used to sign the typed data for the %%signature%%.
   */
  export declare function verifyTypedData(
    domain: TypedDataDomain,
    types: Record<string, Array<TypedDataField>>,
    value: Record<string, any>,
    signature: SignatureLike
  ): string;
  /**
   *  A Signer represents an account on the Ethereum Blockchain, and is most often
   *  backed by a private key represented by a mnemonic or residing on a Hardware Wallet.
   *
   *  The API remains abstract though, so that it can deal with more advanced exotic
   *  Signing entities, such as Smart Contract Wallets or Virtual Wallets (where the
   *  private key may not be known).
   */
  export interface Signer extends Addressable, ContractRunner, NameResolver {
    /**
     *  The [[Provider]] attached to this Signer (if any).
     */
    provider: null | Provider;
    /**
     *  Returns a new instance of this Signer connected to //provider// or detached
     *  from any Provider if null.
     */
    connect(provider: null | Provider): Signer;
    /**
     *  Get the address of the Signer.
     */
    getAddress(): Promise<string>;
    /**
     *  Gets the next nonce required for this Signer to send a transaction.
     *
     *  @param blockTag - The blocktag to base the transaction count on, keep in mind
     *         many nodes do not honour this value and silently ignore it [default: ``"latest"``]
     */
    getNonce(blockTag?: BlockTag): Promise<number>;
    /**
     *  Prepares a {@link TransactionRequest} for calling:
     *  - resolves ``to`` and ``from`` addresses
     *  - if ``from`` is specified , check that it matches this Signer
     *
     *  @param tx - The call to prepare
     */
    populateCall(tx: TransactionRequest): Promise<TransactionLike<string>>;
    /**
     *  Prepares a {@link TransactionRequest} for sending to the network by
     *  populating any missing properties:
     *  - resolves ``to`` and ``from`` addresses
     *  - if ``from`` is specified , check that it matches this Signer
     *  - populates ``nonce`` via ``signer.getNonce("pending")``
     *  - populates ``gasLimit`` via ``signer.estimateGas(tx)``
     *  - populates ``chainId`` via ``signer.provider.getNetwork()``
     *  - populates ``type`` and relevant fee data for that type (``gasPrice``
     *    for legacy transactions, ``maxFeePerGas`` for EIP-1559, etc)
     *
     *  @note Some Signer implementations may skip populating properties that
     *        are populated downstream; for example JsonRpcSigner defers to the
     *        node to populate the nonce and fee data.
     *
     *  @param tx - The call to prepare
     */
    populateTransaction(
      tx: TransactionRequest
    ): Promise<TransactionLike<string>>;
    /**
     *  Estimates the required gas required to execute //tx// on the Blockchain. This
     *  will be the expected amount a transaction will require as its ``gasLimit``
     *  to successfully run all the necessary computations and store the needed state
     *  that the transaction intends.
     *
     *  Keep in mind that this is **best efforts**, since the state of the Blockchain
     *  is in flux, which could affect transaction gas requirements.
     *
     *  @throws UNPREDICTABLE_GAS_LIMIT A transaction that is believed by the node to likely
     *          fail will throw an error during gas estimation. This could indicate that it
     *          will actually fail or that the circumstances are simply too complex for the
     *          node to take into account. In these cases, a manually determined ``gasLimit``
     *          will need to be made.
     */
    estimateGas(tx: TransactionRequest): Promise<bigint>;
    /**
     *  Evaluates the //tx// by running it against the current Blockchain state. This
     *  cannot change state and has no cost in ether, as it is effectively simulating
     *  execution.
     *
     *  This can be used to have the Blockchain perform computations based on its state
     *  (e.g. running a Contract's getters) or to simulate the effect of a transaction
     *  before actually performing an operation.
     */
    call(tx: TransactionRequest): Promise<string>;
    /**
     *  Resolves an ENS Name to an address.
     */
    resolveName(name: string): Promise<null | string>;
    /**
     *  Signs %%tx%%, returning the fully signed transaction. This does not
     *  populate any additional properties within the transaction.
     */
    signTransaction(tx: TransactionRequest): Promise<string>;
    /**
     *  Sends %%tx%% to the Network. The ``signer.populateTransaction(tx)``
     *  is called first to ensure all necessary properties for the
     *  transaction to be valid have been popualted first.
     */
    sendTransaction(tx: TransactionRequest): Promise<TransactionResponse>;
    /**
     *  Signers an [[link-eip-191]] prefixed personal message.
     *
     *  If the %%message%% is a string, it is signed as UTF-8 encoded bytes. It is **not**
     *  interpretted as a [[BytesLike]]; so the string ``"0x1234"`` is signed as six
     *  characters, **not** two bytes.
     *
     *  To sign that example as two bytes, the Uint8Array should be used
     *  (i.e. ``new Uint8Array([ 0x12, 0x34 ])``).
     */
    signMessage(message: string | Uint8Array): Promise<string>;
    /**
     *  Signs the [[link-eip-712]] typed data.
     */
    signTypedData(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): Promise<string>;
  }
  /**
   *  An **AbstractSigner** includes most of teh functionality required
   *  to get a [[Signer]] working as expected, but requires a few
   *  Signer-specific methods be overridden.
   *
   */
  export declare abstract class AbstractSigner<
    P extends null | Provider = null | Provider
  > implements Signer
  {
    /**
     *  The provider this signer is connected to.
     */
    readonly provider: P;
    /**
     *  Creates a new Signer connected to %%provider%%.
     */
    constructor(provider?: P);
    /**
     *  Resolves to the Signer address.
     */
    abstract getAddress(): Promise<string>;
    /**
     *  Returns the signer connected to %%provider%%.
     *
     *  This may throw, for example, a Signer connected over a Socket or
     *  to a specific instance of a node may not be transferrable.
     */
    abstract connect(provider: null | Provider): Signer;
    getNonce(blockTag?: BlockTag): Promise<number>;
    populateCall(tx: TransactionRequest): Promise<TransactionLike<string>>;
    populateTransaction(
      tx: TransactionRequest
    ): Promise<TransactionLike<string>>;
    estimateGas(tx: TransactionRequest): Promise<bigint>;
    call(tx: TransactionRequest): Promise<string>;
    resolveName(name: string): Promise<null | string>;
    sendTransaction(tx: TransactionRequest): Promise<TransactionResponse>;
    abstract signTransaction(tx: TransactionRequest): Promise<string>;
    abstract signMessage(message: string | Uint8Array): Promise<string>;
    abstract signTypedData(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): Promise<string>;
  }
  /**
   *  A **VoidSigner** is a class deisgned to allow an address to be used
   *  in any API which accepts a Signer, but for which there are no
   *  credentials available to perform any actual signing.
   *
   *  This for example allow impersonating an account for the purpose of
   *  static calls or estimating gas, but does not allow sending transactions.
   */
  export declare class VoidSigner extends AbstractSigner {
    #private;
    /**
     *  The signer address.
     */
    readonly address: string;
    /**
     *  Creates a new **VoidSigner** with %%address%% attached to
     *  %%provider%%.
     */
    constructor(address: string, provider?: null | Provider);
    getAddress(): Promise<string>;
    connect(provider: null | Provider): VoidSigner;
    signTransaction(tx: TransactionRequest): Promise<string>;
    signMessage(message: string | Uint8Array): Promise<string>;
    signTypedData(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): Promise<string>;
  }
  /**
   *  There are many awesome community services that provide Ethereum
   *  nodes both for developers just starting out and for large-scale
   *  communities.
   *
   *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]
   */
  /**
   *  Providers which offer community credentials should extend this
   *  to notify any interested consumers whether community credentials
   *  are in-use.
   */
  export interface CommunityResourcable {
    /**
     *  Returns true of the instance is connected using the community
     *  credentials.
     */
    isCommunityResource(): boolean;
  }
  /**
   *  Displays a warning in tht console when the community resource is
   *  being used too heavily by the app, recommending the developer
   *  acquire their own credentials instead of using the community
   *  credentials.
   *
   *  The notification will only occur once per service.
   */
  export declare function showThrottleMessage(service: string): void;
  /**
   *  A JSON-RPC payload, which are sent to a JSON-RPC server.
   */
  export type JsonRpcPayload = {
    /**
     *  The JSON-RPC request ID.
     */
    id: number;
    /**
     *  The JSON-RPC request method.
     */
    method: string;
    /**
     *  The JSON-RPC request parameters.
     */
    params: Array<any> | Record<string, any>;
    /**
     *  A required constant in the JSON-RPC specification.
     */
    jsonrpc: "2.0";
  };
  /**
   *  A JSON-RPC result, which are returned on success from a JSON-RPC server.
   */
  export type JsonRpcResult = {
    /**
     *  The response ID to match it to the relevant request.
     */
    id: number;
    /**
     *  The response result.
     */
    result: any;
  };
  /**
   *  A JSON-RPC error, which are returned on failure from a JSON-RPC server.
   */
  export type JsonRpcError = {
    /**
     *  The response ID to match it to the relevant request.
     */
    id: number;
    /**
     *  The response error.
     */
    error: {
      code: number;
      message?: string;
      data?: any;
    };
  };
  /**
   *  Options for configuring a [[JsonRpcApiProvider]]. Much of this
   *  is targetted towards sub-classes, which often will not expose
   *  any of these options to their consumers.
   *
   *  **``polling``** - use the polling strategy is used immediately
   *  for events; otherwise, attempt to use filters and fall back onto
   *  polling (default: ``false``)
   *
   *  **``staticNetwork``** - do not request chain ID on requests to
   *  validate the underlying chain has not changed (default: ``null``)
   *
   *  This should **ONLY** be used if it is **certain** that the network
   *  cannot change, such as when using INFURA (since the URL dictates the
   *  network). If the network is assumed static and it does change, this
   *  can have tragic consequences. For example, this **CANNOT** be used
   *  with MetaMask, since the used can select a new network from the
   *  drop-down at any time.
   *
   *  **``batchStallTime``** - how long (ms) to aggregate requests into a
   *  single batch. ``0`` indicates batching will only encompass the current
   *  event loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)
   *
   *  **``batchMaxSize``** - target maximum size (bytes) to allow per batch
   *  request (default: 1Mb)
   *
   *  **``batchMaxCount``** - maximum number of requests to allow in a batch.
   *  If ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)
   *
   *  **``cacheTimeout``** - passed as [[AbstractProviderOptions]].
   */
  export type JsonRpcApiProviderOptions = {
    polling?: boolean;
    staticNetwork?: null | Network;
    batchStallTime?: number;
    batchMaxSize?: number;
    batchMaxCount?: number;
    cacheTimeout?: number;
  };
  /**
   *  A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC
   *  Ethereum API specification.
   */
  export interface JsonRpcTransactionRequest {
    /**
     *  The sender address to use when signing.
     */
    from?: string;
    /**
     *  The target address.
     */
    to?: string;
    /**
     *  The transaction data.
     */
    data?: string;
    /**
     *  The chain ID the transaction is valid on.
     */
    chainId?: string;
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    type?: string;
    /**
     *  The maximum amount of gas to allow a transaction to consume.
     *
     *  In most other places in ethers, this is called ``gasLimit`` which
     *  differs from the JSON-RPC Ethereum API specification.
     */
    gas?: string;
    /**
     *  The gas price per wei for transactions prior to [[link-eip-1559]].
     */
    gasPrice?: string;
    /**
     *  The maximum fee per gas for [[link-eip-1559]] transactions.
     */
    maxFeePerGas?: string;
    /**
     *  The maximum priority fee per gas for [[link-eip-1559]] transactions.
     */
    maxPriorityFeePerGas?: string;
    /**
     *  The nonce for the transaction.
     */
    nonce?: string;
    /**
     *  The transaction value (in wei).
     */
    value?: string;
    /**
     *  The transaction access list.
     */
    accessList?: Array<{
      address: string;
      storageKeys: Array<string>;
    }>;
  }
  export declare class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {
    address: string;
    constructor(provider: JsonRpcApiProvider, address: string);
    connect(provider: null | Provider): Signer;
    getAddress(): Promise<string>;
    populateTransaction(
      tx: TransactionRequest
    ): Promise<TransactionLike<string>>;
    sendUncheckedTransaction(_tx: TransactionRequest): Promise<string>;
    sendTransaction(tx: TransactionRequest): Promise<TransactionResponse>;
    signTransaction(_tx: TransactionRequest): Promise<string>;
    signMessage(_message: string | Uint8Array): Promise<string>;
    signTypedData(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      _value: Record<string, any>
    ): Promise<string>;
    unlock(password: string): Promise<boolean>;
    _legacySignMessage(_message: string | Uint8Array): Promise<string>;
  }
  /**
   *  The JsonRpcApiProvider is an abstract class and **MUST** be
   *  sub-classed.
   *
   *  It provides the base for all JSON-RPC-based Provider interaction.
   *
   *  Sub-classing Notes:
   *  - a sub-class MUST override _send
   *  - a sub-class MUST call the `_start()` method once connected
   */
  export declare abstract class JsonRpcApiProvider extends AbstractProvider {
    #private;
    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions);
    /**
     *  Returns the value associated with the option %%key%%.
     *
     *  Sub-classes can use this to inquire about configuration options.
     */
    _getOption<K extends keyof JsonRpcApiProviderOptions>(
      key: K
    ): JsonRpcApiProviderOptions[K];
    /**
     *  Gets the [[Network]] this provider has committed to. On each call, the network
     *  is detected, and if it has changed, the call will reject.
     */
    get _network(): Network;
    /**
     *  Sends a JSON-RPC %%payload%% (or a batch) to the underlying channel.
     *
     *  Sub-classes **MUST** override this.
     */
    abstract _send(
      payload: JsonRpcPayload | Array<JsonRpcPayload>
    ): Promise<Array<JsonRpcResult | JsonRpcError>>;
    /**
     *  Resolves to the non-normalized value by performing %%req%%.
     *
     *  Sub-classes may override this to modify behavior of actions,
     *  and should generally call ``super._perform`` as a fallback.
     */
    _perform(req: PerformActionRequest): Promise<any>;
    /**
     *  Sub-classes may override this; it detects the *actual* network that
     *  we are **currently** connected to.
     *
     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
     *  _send primitive must be used instead.
     */
    _detectNetwork(): Promise<Network>;
    /**
     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
     *  will be passed to [[_send]] from [[send]]. If it is overridden, then
     *  ``super._start()`` **MUST** be called.
     *
     *  Calling it multiple times is safe and has no effect.
     */
    _start(): void;
    /**
     *  Resolves once the [[_start]] has been called. This can be used in
     *  sub-classes to defer sending data until the connection has been
     *  established.
     */
    _waitUntilReady(): Promise<void>;
    /**
     *  Return a Subscriber that will manage the %%sub%%.
     *
     *  Sub-classes may override this to modify the behavior of
     *  subscription management.
     */
    _getSubscriber(sub: Subscription): Subscriber;
    /**
     *  Returns true only if the [[_start]] has been called.
     */
    get ready(): boolean;
    /**
     *  Returns %%tx%% as a normalized JSON-RPC transaction request,
     *  which has all values hexlified and any numeric values converted
     *  to Quantity values.
     */
    getRpcTransaction(tx: TransactionRequest): JsonRpcTransactionRequest;
    /**
     *  Returns the request method and arguments required to perform
     *  %%req%%.
     */
    getRpcRequest(req: PerformActionRequest): null | {
      method: string;
      args: Array<any>;
    };
    /**
     *  Returns an ethers-style Error for the given JSON-RPC error
     *  %%payload%%, coalescing the various strings and error shapes
     *  that different nodes return, coercing them into a machine-readable
     *  standardized error.
     */
    getRpcError(payload: JsonRpcPayload, _error: JsonRpcError): Error;
    /**
     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
     *  over the underlying channel. This can be used to call methods
     *  on the backend that do not have a high-level API within the Provider
     *  API.
     *
     *  This method queues requests according to the batch constraints
     *  in the options, assigns the request a unique ID.
     *
     *  **Do NOT override** this method in sub-classes; instead
     *  override [[_send]] or force the options values in the
     *  call to the constructor to modify this method's behavior.
     */
    send(
      method: string,
      params: Array<any> | Record<string, any>
    ): Promise<any>;
    /**
     *  Resolves to the [[Signer]] account for  %%address%% managed by
     *  the client.
     *
     *  If the %%address%% is a number, it is used as an index in the
     *  the accounts from [[listAccounts]].
     *
     *  This can only be used on clients which manage accounts (such as
     *  Geth with imported account or MetaMask).
     *
     *  Throws if the account doesn't exist.
     */
    getSigner(address?: number | string): Promise<JsonRpcSigner>;
    listAccounts(): Promise<Array<JsonRpcSigner>>;
    destroy(): void;
  }
  declare abstract class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
    #private;
    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions);
    _getSubscriber(sub: Subscription): Subscriber;
    /**
     *  The polling interval (default: 4000 ms)
     */
    get pollingInterval(): number;
    set pollingInterval(value: number);
  }
  /**
   *  The JsonRpcProvider is one of the most common Providers,
   *  which performs all operations over HTTP (or HTTPS) requests.
   *
   *  Events are processed by polling the backend for the current block
   *  number; when it advances, all block-base events are then checked
   *  for updates.
   */
  export declare class JsonRpcProvider extends JsonRpcApiPollingProvider {
    #private;
    constructor(
      url?: string | FetchRequest,
      network?: Networkish,
      options?: JsonRpcApiProviderOptions
    );
    _getConnection(): FetchRequest;
    send(
      method: string,
      params: Array<any> | Record<string, any>
    ): Promise<any>;
    _send(
      payload: JsonRpcPayload | Array<JsonRpcPayload>
    ): Promise<Array<JsonRpcResult>>;
  }
  /**
   *  A **SocketSubscriber** uses a socket transport to handle events and
   *  should use [[_emit]] to manage the events.
   */
  export declare class SocketSubscriber implements Subscriber {
    #private;
    /**
     *  The filter.
     */
    get filter(): Array<any>;
    /**
     *  Creates a new **SocketSubscriber** attached to %%provider%% listening
     *  to %%filter%%.
     */
    constructor(provider: SocketProvider, filter: Array<any>);
    start(): void;
    stop(): void;
    pause(dropWhilePaused?: boolean): void;
    resume(): void;
    /**
     *  @_ignore:
     */
    _handleMessage(message: any): void;
    /**
     *  Sub-classes **must** override this to emit the events on the
     *  provider.
     */
    _emit(provider: SocketProvider, message: any): Promise<void>;
  }
  /**
   *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits
   *  ``"block"`` events.
   */
  export declare class SocketBlockSubscriber extends SocketSubscriber {
    /**
     *  @_ignore:
     */
    constructor(provider: SocketProvider);
    _emit(provider: SocketProvider, message: any): Promise<void>;
  }
  /**
   *  A **SocketPendingSubscriber** listens for pending transacitons and emits
   *  ``"pending"`` events.
   */
  export declare class SocketPendingSubscriber extends SocketSubscriber {
    /**
     *  @_ignore:
     */
    constructor(provider: SocketProvider);
    _emit(provider: SocketProvider, message: any): Promise<void>;
  }
  /**
   *  A **SocketEventSubscriber** listens for event logs.
   */
  export declare class SocketEventSubscriber extends SocketSubscriber {
    #private;
    /**
     *  The filter.
     */
    get logFilter(): EventFilter;
    /**
     *  @_ignore:
     */
    constructor(provider: SocketProvider, filter: EventFilter);
    _emit(provider: SocketProvider, message: any): Promise<void>;
  }
  /**
   *  A **SocketProvider** is backed by a long-lived connection over a
   *  socket, which can subscribe and receive real-time messages over
   *  its communication channel.
   */
  export declare class SocketProvider extends JsonRpcApiProvider {
    #private;
    /**
     *  Creates a new **SocketProvider** connected to %%network%%.
     *
     *  If unspecified, the network will be discovered.
     */
    constructor(network?: Networkish);
    _getSubscriber(sub: Subscription): Subscriber;
    /**
     *  Register a new subscriber. This is used internalled by Subscribers
     *  and generally is unecessary unless extending capabilities.
     */
    _register(filterId: number | string, subscriber: SocketSubscriber): void;
    _send(
      payload: JsonRpcPayload | Array<JsonRpcPayload>
    ): Promise<Array<JsonRpcResult | JsonRpcError>>;
    /**
     *  Sub-classes **must** call this with messages received over their
     *  transport to be processed and dispatched.
     */
    _processMessage(message: string): Promise<void>;
    /**
     *  Sub-classes **must** override this to send %%message%% over their
     *  transport.
     */
    _write(message: string): Promise<void>;
  }
  /**
   *  A generic interface to a Websocket-like object.
   */
  export interface WebSocketLike {
    onopen: null | ((...args: Array<any>) => any);
    onmessage: null | ((...args: Array<any>) => any);
    onerror: null | ((...args: Array<any>) => any);
    readyState: number;
    send(payload: any): void;
    close(code?: number, reason?: string): void;
  }
  /**
   *  A function which can be used to re-create a WebSocket connection
   *  on disconnect.
   */
  export type WebSocketCreator = () => WebSocketLike;
  /**
   *  A JSON-RPC provider which is backed by a WebSocket.
   *
   *  WebSockets are often preferred because they retain a live connection
   *  to a server, which permits more instant access to events.
   *
   *  However, this incurs higher server infrasturture costs, so additional
   *  resources may be required to host your own WebSocket nodes and many
   *  third-party services charge additional fees for WebSocket endpoints.
   */
  export declare class WebSocketProvider extends SocketProvider {
    #private;
    get websocket(): WebSocketLike;
    constructor(
      url: string | WebSocketLike | WebSocketCreator,
      network?: Networkish
    );
    _write(message: string): Promise<void>;
    destroy(): Promise<void>;
  }
  export declare function getDefaultProvider(
    network: string | Networkish | WebSocketLike,
    options?: any
  ): AbstractProvider;
  /**
   *  A **NonceManager** wraps another [[Signer]] and automatically manages
   *  the nonce, ensuring serialized and sequential nonces are used during
   *  transaction.
   */
  export declare class NonceManager extends AbstractSigner {
    #private;
    /**
     *  The Signer being managed.
     */
    signer: Signer;
    /**
     *  Creates a new **NonceManager** to manage %%signer%%.
     */
    constructor(signer: Signer);
    getAddress(): Promise<string>;
    connect(provider: null | Provider): NonceManager;
    getNonce(blockTag?: BlockTag): Promise<number>;
    /**
     *  Manually increment the nonce. This may be useful when managng
     *  offline transactions.
     */
    increment(): void;
    /**
     *  Resets the nonce, causing the **NonceManager** to reload the current
     *  nonce from the blockchain on the next transaction.
     */
    reset(): void;
    sendTransaction(tx: TransactionRequest): Promise<TransactionResponse>;
    signTransaction(tx: TransactionRequest): Promise<string>;
    signMessage(message: string | Uint8Array): Promise<string>;
    signTypedData(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): Promise<string>;
  }
  /**
   *  A configuration entry for how to use a [[Provider]].
   */
  export interface FallbackProviderConfig {
    /**
     *  The provider.
     */
    provider: AbstractProvider;
    /**
     *  The amount of time to wait before kicking off the next provider.
     *
     *  Any providers that have not responded can still respond and be
     *  counted, but this ensures new providers start.
     */
    stallTimeout?: number;
    /**
     *  The priority. Lower priority providers are dispatched first.
     */
    priority?: number;
    /**
     *  The amount of weight a provider is given against the quorum.
     */
    weight?: number;
  }
  /**
   *  The statistics and state maintained for a [[Provider]].
   */
  export interface FallbackProviderState
    extends Required<FallbackProviderConfig> {
    /**
     *  The most recent blockNumber this provider has reported (-2 if none).
     */
    blockNumber: number;
    /**
     *  The number of total requests ever sent to this provider.
     */
    requests: number;
    /**
     *  The number of responses that errored.
     */
    errorResponses: number;
    /**
     *  The number of responses that occured after the result resolved.
     */
    lateResponses: number;
    /**
     *  How many times syncing was required to catch up the expected block.
     */
    outOfSync: number;
    /**
     *  The number of requests which reported unsupported operation.
     */
    unsupportedEvents: number;
    /**
     *  A rolling average (5% current duration) for response time.
     */
    rollingDuration: number;
    /**
     *  The ratio of quorum-agreed results to total.
     */
    score: number;
  }
  /**
   *  A **FallbackProvider** manages several [[Providers]] providing
   *  resiliance by switching between slow or misbehaving nodes, security
   *  by requiring multiple backends to aggree and performance by allowing
   *  faster backends to respond earlier.
   *
   */
  export declare class FallbackProvider extends AbstractProvider {
    #private;
    /**
     *  The number of backends that must agree on a value before it is
     *  accpeted.
     */
    readonly quorum: number;
    /**
     *  @_ignore:
     */
    readonly eventQuorum: number;
    /**
     *  @_ignore:
     */
    readonly eventWorkers: number;
    /**
     *  Creates a new **FallbackProvider** with %%providers%% connected to
     *  %%network%%.
     *
     *  If a [[Provider]] is included in %%providers%%, defaults are used
     *  for the configuration.
     */
    constructor(
      providers: Array<AbstractProvider | FallbackProviderConfig>,
      network?: Networkish
    );
    get providerConfigs(): Array<FallbackProviderState>;
    _detectNetwork(): Promise<Network>;
    /**
     *  Transforms a %%req%% into the correct method call on %%provider%%.
     */
    _translatePerform(
      provider: AbstractProvider,
      req: PerformActionRequest
    ): Promise<any>;
    _perform<T = any>(req: PerformActionRequest): Promise<T>;
    destroy(): Promise<void>;
  }
  /**
   *  The interface to an [[link-eip-1193]] provider, which is a standard
   *  used by most injected providers, which the [[BrowserProvider]] accepts
   *  and exposes the API of.
   */
  export interface Eip1193Provider {
    /**
     *  See [[link-eip-1193]] for details on this method.
     */
    request(request: {
      method: string;
      params?: Array<any> | Record<string, any>;
    }): Promise<any>;
  }
  /**
   *  The possible additional events dispatched when using the ``"debug"``
   *  event on a [[BrowserProvider]].
   */
  export type DebugEventBrowserProvider =
    | {
        action: "sendEip1193Payload";
        payload: {
          method: string;
          params: Array<any>;
        };
      }
    | {
        action: "receiveEip1193Result";
        result: any;
      }
    | {
        action: "receiveEip1193Error";
        error: Error;
      };
  /**
   *  A **BrowserProvider** is intended to wrap an injected provider which
   *  adheres to the [[link-eip-1193]] standard, which most (if not all)
   *  currently do.
   */
  export declare class BrowserProvider extends JsonRpcApiPollingProvider {
    #private;
    /**
     *  Connnect to the %%ethereum%% provider, optionally forcing the
     *  %%network%%.
     */
    constructor(ethereum: Eip1193Provider, network?: Networkish);
    send(
      method: string,
      params: Array<any> | Record<string, any>
    ): Promise<any>;
    _send(
      payload: JsonRpcPayload | Array<JsonRpcPayload>
    ): Promise<Array<JsonRpcResult | JsonRpcError>>;
    getRpcError(payload: JsonRpcPayload, error: JsonRpcError): Error;
    /**
     *  Resolves to ``true`` if the provider manages the %%address%%.
     */
    hasSigner(address: number | string): Promise<boolean>;
    getSigner(address?: number | string): Promise<JsonRpcSigner>;
  }
  /**
   *  The **AlchemyProvider** connects to the [[link-alchemy]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-alchemy-signup).
   *
   *  @_docloc: api/providers/thirdparty
   */
  export declare class AlchemyProvider
    extends JsonRpcProvider
    implements CommunityResourcable
  {
    readonly apiKey: string;
    constructor(_network?: Networkish, apiKey?: null | string);
    _getProvider(chainId: number): AbstractProvider;
    _perform(req: PerformActionRequest): Promise<any>;
    isCommunityResource(): boolean;
    static getRequest(network: Network, apiKey?: string): FetchRequest;
  }
  /**
   *  The **AnkrProvider** connects to the [[link-ankr]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-ankr-signup).
   */
  export declare class AnkrProvider
    extends JsonRpcProvider
    implements CommunityResourcable
  {
    /**
     *  The API key for the Ankr connection.
     */
    readonly apiKey: string;
    /**
     *  Create a new **AnkrProvider**.
     *
     *  By default connecting to ``mainnet`` with a highly throttled
     *  API key.
     */
    constructor(_network?: Networkish, apiKey?: null | string);
    _getProvider(chainId: number): AbstractProvider;
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%apiKey%%.
     */
    static getRequest(network: Network, apiKey?: null | string): FetchRequest;
    getRpcError(payload: JsonRpcPayload, error: JsonRpcError): Error;
    isCommunityResource(): boolean;
  }
  /**
   *  About Cloudflare...
   */
  export declare class CloudflareProvider extends JsonRpcProvider {
    constructor(_network?: Networkish);
  }
  /**
   *  The name for an event used for subscribing to Contract events.
   *
   *  **``string``** - An event by name. The event must be non-ambiguous.
   *  The parameters will be dereferenced when passed into the listener.
   *
   *  [[ContractEvent]] - A filter from the ``contract.filters``, which will
   *  pass only the EventPayload as a single parameter, which includes a
   *  ``.signature`` property that can be used to further filter the event.
   *
   *  [[TopicFilter]] - A filter defined using the standard Ethereum API
   *  which provides the specific topic hash or topic hashes to watch for along
   *  with any additional values to filter by. This will only pass a single
   *  parameter to the listener, the EventPayload which will include additional
   *  details to refine by, such as the event name and signature.
   *
   *  [[DeferredTopicFilter]] - A filter created by calling a [[ContractEvent]]
   *  with parameters, which will create a filter for a specific event
   *  signautre and dereference each parameter when calling the listener.
   */
  export type ContractEventName =
    | string
    | ContractEvent
    | TopicFilter
    | DeferredTopicFilter;
  /**
   *  A Contract with no method constraints.
   */
  export interface ContractInterface {
    [name: string]: BaseContractMethod;
  }
  /**
   *  When creating a filter using the ``contract.filters``, this is returned.
   */
  export interface DeferredTopicFilter {
    getTopicFilter(): Promise<TopicFilter>;
    fragment: EventFragment;
  }
  /**
   *  When populating a transaction this type is returned.
   */
  export interface ContractTransaction extends PreparedTransactionRequest {
    /**
     *  The target address.
     */
    to: string;
    /**
     *  The transaction data.
     */
    data: string;
    /**
     *  The from address, if any.
     */
    from?: string;
  }
  /**
   *  A deployment transaction for a contract.
   */
  export interface ContractDeployTransaction
    extends Omit<ContractTransaction, "to"> {}
  /**
   *  The overrides for a contract transaction.
   */
  export interface Overrides extends Omit<TransactionRequest, "to" | "data"> {}
  /**
   *  Arguments to a Contract method can always include an additional and
   *  optional overrides parameter.
   *
   *  @_ignore:
   */
  export type PostfixOverrides<A extends Array<any>> = A | [...A, Overrides];
  /**
   *  Arguments to a Contract method can always include an additional and
   *  optional overrides parameter, and each parameter can optionally be
   *  [[Typed]].
   *
   *  @_ignore:
   */
  export type ContractMethodArgs<A extends Array<any>> = PostfixOverrides<{
    [I in keyof A]-?: A[I] | Typed;
  }>;
  /**
   *  A Contract method can be called directly, or used in various ways.
   */
  export interface BaseContractMethod<
    A extends Array<any> = Array<any>,
    R = any,
    D extends R | ContractTransactionResponse = R | ContractTransactionResponse
  > {
    (...args: ContractMethodArgs<A>): Promise<D>;
    /**
     *  The name of the Contract method.
     */
    name: string;
    /**
     *  The fragment of the Contract method. This will throw on ambiguous
     *  method names.
     */
    fragment: FunctionFragment;
    /**
     *  Returns the fragment constrained by %%args%%. This can be used to
     *  resolve ambiguous method names.
     */
    getFragment(...args: ContractMethodArgs<A>): FunctionFragment;
    /**
     *  Returns a populated transaction that can be used to perform the
     *  contract method with %%args%%.
     */
    populateTransaction(
      ...args: ContractMethodArgs<A>
    ): Promise<ContractTransaction>;
    /**
     *  Call the contract method with %%args%% and return the value.
     *
     *  If the return value is a single type, it will be dereferenced and
     *  returned directly, otherwise the full Result will be returned.
     */
    staticCall(...args: ContractMethodArgs<A>): Promise<R>;
    /**
     *  Send a transaction for the contract method with %%args%%.
     */
    send(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse>;
    /**
     *  Estimate the gas to send the contract method with %%args%%.
     */
    estimateGas(...args: ContractMethodArgs<A>): Promise<bigint>;
    /**
     *  Call the contract method with %%args%% and return the Result
     *  without any dereferencing.
     */
    staticCallResult(...args: ContractMethodArgs<A>): Promise<Result>;
  }
  /**
   *  A contract method on a Contract.
   */
  export interface ContractMethod<
    A extends Array<any> = Array<any>,
    R = any,
    D extends R | ContractTransactionResponse = R | ContractTransactionResponse
  > extends BaseContractMethod<A, R, D> {}
  /**
   *  A pure of view method on a Contract.
   */
  export interface ConstantContractMethod<A extends Array<any>, R = any>
    extends ContractMethod<A, R, R> {}
  /**
   *  Each argument of an event is nullable (to indicate matching //any//.
   *
   *  @_ignore:
   */
  export type ContractEventArgs<A extends Array<any>> = {
    [I in keyof A]?: A[I] | Typed | null;
  };
  export interface ContractEvent<A extends Array<any> = Array<any>> {
    (...args: ContractEventArgs<A>): DeferredTopicFilter;
    /**
     *  The name of the Contract event.
     */
    name: string;
    /**
     *  The fragment of the Contract event. This will throw on ambiguous
     *  method names.
     */
    fragment: EventFragment;
    /**
     *  Returns the fragment constrained by %%args%%. This can be used to
     *  resolve ambiguous event names.
     */
    getFragment(...args: ContractEventArgs<A>): EventFragment;
  }
  /**
   *  A Fallback or Receive function on a Contract.
   */
  export interface WrappedFallback {
    (
      overrides?: Omit<TransactionRequest, "to">
    ): Promise<ContractTransactionResponse>;
    /**
     *  Returns a populated transaction that can be used to perform the
     *  fallback method.
     *
     *  For non-receive fallback, ``data`` may be overridden.
     */
    populateTransaction(
      overrides?: Omit<TransactionRequest, "to">
    ): Promise<ContractTransaction>;
    /**
     *  Call the contract fallback and return the result.
     *
     *  For non-receive fallback, ``data`` may be overridden.
     */
    staticCall(overrides?: Omit<TransactionRequest, "to">): Promise<string>;
    /**
     *  Send a transaction to the contract fallback.
     *
     *  For non-receive fallback, ``data`` may be overridden.
     */
    send(
      overrides?: Omit<TransactionRequest, "to">
    ): Promise<ContractTransactionResponse>;
    /**
     *  Estimate the gas to send a transaction to the contract fallback.
     *
     *  For non-receive fallback, ``data`` may be overridden.
     */
    estimateGas(overrides?: Omit<TransactionRequest, "to">): Promise<bigint>;
  }
  /**
   *  An **EventLog** contains additional properties parsed from the [[Log]].
   */
  export declare class EventLog extends Log {
    /**
     *  The Contract Interface.
     */
    readonly interface: Interface;
    /**
     *  The matching event.
     */
    readonly fragment: EventFragment;
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    readonly args: Result;
    /**
     * @_ignore:
     */
    constructor(log: Log, iface: Interface, fragment: EventFragment);
    /**
     *  The name of the event.
     */
    get eventName(): string;
    /**
     *  The signature of the event.
     */
    get eventSignature(): string;
  }
  /**
   *  A **ContractTransactionReceipt** includes the parsed logs from a
   *  [[TransactionReceipt]].
   */
  export declare class ContractTransactionReceipt extends TransactionReceipt {
    #private;
    /**
     *  @_ignore:
     */
    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt);
    /**
     *  The parsed logs for any [[Log]] which has a matching event in the
     *  Contract ABI.
     */
    get logs(): Array<EventLog | Log>;
  }
  /**
   *  A **ContractTransactionResponse** will return a
   *  [[ContractTransactionReceipt]] when waited on.
   */
  export declare class ContractTransactionResponse extends TransactionResponse {
    #private;
    /**
     *  @_ignore:
     */
    constructor(iface: Interface, provider: Provider, tx: TransactionResponse);
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    wait(confirms?: number): Promise<null | ContractTransactionReceipt>;
  }
  /**
   *  A **ContractUnknownEventPayload** is included as the last parameter to
   *  Contract Events when the event does not match any events in the ABI.
   */
  export declare class ContractUnknownEventPayload extends EventPayload<ContractEventName> {
    /**
     *  The log with no matching events.
     */
    readonly log: Log;
    /**
     *  @_event:
     */
    constructor(
      contract: BaseContract,
      listener: null | Listener,
      filter: ContractEventName,
      log: Log
    );
    /**
     *  Resolves to the block the event occured in.
     */
    getBlock(): Promise<Block>;
    /**
     *  Resolves to the transaction the event occured in.
     */
    getTransaction(): Promise<TransactionResponse>;
    /**
     *  Resolves to the transaction receipt the event occured in.
     */
    getTransactionReceipt(): Promise<TransactionReceipt>;
  }
  /**
   *  A **ContractEventPayload** is included as the last parameter to
   *  Contract Events when the event is known.
   */
  export declare class ContractEventPayload extends ContractUnknownEventPayload {
    /**
     *  The matching event.
     */
    readonly fragment: EventFragment;
    /**
     *  The log, with parsed properties.
     */
    readonly log: EventLog;
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    readonly args: Result;
    /**
     *  @_ignore:
     */
    constructor(
      contract: BaseContract,
      listener: null | Listener,
      filter: ContractEventName,
      fragment: EventFragment,
      _log: Log
    );
    /**
     *  The event name.
     */
    get eventName(): string;
    /**
     *  The event signature.
     */
    get eventSignature(): string;
  }
  declare const internal: unique symbol;
  export declare class BaseContract
    implements Addressable, EventEmitterable<ContractEventName>
  {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    readonly target: string | Addressable;
    /**
     *  The contract Interface.
     */
    readonly interface: Interface;
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    readonly runner: null | ContractRunner;
    /**
     *  All the Events available on this contract.
     */
    readonly filters: Record<string, ContractEvent>;
    /**
     *  @_ignore:
     */
    readonly [internal]: any;
    /**
     *  The fallback or receive function if any.
     */
    readonly fallback: null | WrappedFallback;
    /**
     *  Creates a new contract connected to %%target%% with the %%abi%% and
     *  optionally connected to a %%runner%% to perform operations on behalf
     *  of.
     */
    constructor(
      target: string | Addressable,
      abi: Interface | InterfaceAbi,
      runner?: null | ContractRunner,
      _deployTx?: null | TransactionResponse
    );
    /**
     *  Return a new Contract instance with the same target and ABI, but
     *  a different %%runner%%.
     */
    connect(runner: null | ContractRunner): BaseContract;
    /**
     *  Return a new Contract instance with the same ABI and runner, but
     *  a different %%target%%.
     */
    attach(target: string | Addressable): BaseContract;
    /**
     *  Return the resolved address of this Contract.
     */
    getAddress(): Promise<string>;
    /**
     *  Return the deployed bytecode or null if no bytecode is found.
     */
    getDeployedCode(): Promise<null | string>;
    /**
     *  Resolve to this Contract once the bytecode has been deployed, or
     *  resolve immediately if already deployed.
     */
    waitForDeployment(): Promise<this>;
    /**
     *  Return the transaction used to deploy this contract.
     *
     *  This is only available if this instance was returned from a
     *  [[ContractFactory]].
     */
    deploymentTransaction(): null | ContractTransactionResponse;
    /**
     *  Return the function for a given name. This is useful when a contract
     *  method name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getFunction<T extends ContractMethod = ContractMethod>(
      key: string | FunctionFragment
    ): T;
    /**
     *  Return the event for a given name. This is useful when a contract
     *  event name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
    getEvent(key: string | EventFragment): ContractEvent;
    /**
     *  @_ignore:
     */
    queryTransaction(hash: string): Promise<Array<EventLog>>;
    /**
     *  Provide historic access to event data for %%event%% in the range
     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
     *  inclusive.
     */
    queryFilter(
      event: ContractEventName,
      fromBlock?: BlockTag,
      toBlock?: BlockTag
    ): Promise<Array<EventLog | Log>>;
    /**
     *  Add an event %%listener%% for the %%event%%.
     */
    on(event: ContractEventName, listener: Listener): Promise<this>;
    /**
     *  Add an event %%listener%% for the %%event%%, but remove the listener
     *  after it is fired once.
     */
    once(event: ContractEventName, listener: Listener): Promise<this>;
    /**
     *  Emit an %%event%% calling all listeners with %%args%%.
     *
     *  Resolves to ``true`` if any listeners were called.
     */
    emit(event: ContractEventName, ...args: Array<any>): Promise<boolean>;
    /**
     *  Resolves to the number of listeners of %%event%% or the total number
     *  of listeners if unspecified.
     */
    listenerCount(event?: ContractEventName): Promise<number>;
    /**
     *  Resolves to the listeners subscribed to %%event%% or all listeners
     *  if unspecified.
     */
    listeners(event?: ContractEventName): Promise<Array<Listener>>;
    /**
     *  Remove the %%listener%% from the listeners for %%event%% or remove
     *  all listeners if unspecified.
     */
    off(event: ContractEventName, listener?: Listener): Promise<this>;
    /**
     *  Remove all the listeners for %%event%% or remove all listeners if
     *  unspecified.
     */
    removeAllListeners(event?: ContractEventName): Promise<this>;
    /**
     *  Alias for [on].
     */
    addListener(event: ContractEventName, listener: Listener): Promise<this>;
    /**
     *  Alias for [off].
     */
    removeListener(event: ContractEventName, listener: Listener): Promise<this>;
    /**
     *  Create a new Class for the %%abi%%.
     */
    static buildClass<T = ContractInterface>(
      abi: Interface | InterfaceAbi
    ): new (target: string, runner?: null | ContractRunner) => BaseContract &
      Omit<T, keyof BaseContract>;
    /**
     *  Create a new BaseContract with a specified Interface.
     */
    static from<T = ContractInterface>(
      target: string,
      abi: Interface | InterfaceAbi,
      runner?: null | ContractRunner
    ): BaseContract & Omit<T, keyof BaseContract>;
  }
  declare const Contract_base: new (
    target: string,
    abi: Interface | InterfaceAbi,
    runner?: ContractRunner | null | undefined
  ) => BaseContract & Omit<ContractInterface, keyof BaseContract>;
  /**
   *  A [[BaseContract]] with no type guards on its methods or events.
   */
  export declare class Contract extends Contract_base {}
  /**
   *  A **ContractFactory** is used to deploy a Contract to the blockchain.
   */
  export declare class ContractFactory<
    A extends Array<any> = Array<any>,
    I = BaseContract
  > {
    /**
     *  The Contract Interface.
     */
    readonly interface: Interface;
    /**
     *  The Contract deployment bytecode. Often called the initcode.
     */
    readonly bytecode: string;
    /**
     *  The ContractRunner to deploy the Contract as.
     */
    readonly runner: null | ContractRunner;
    /**
     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
     *  optionally connected to %%runner%%.
     *
     *  The %%bytecode%% may be the ``bytecode`` property within the
     *  standard Solidity JSON output.
     */
    constructor(
      abi: Interface | InterfaceAbi,
      bytecode:
        | BytesLike
        | {
            object: string;
          },
      runner?: null | ContractRunner
    );
    attach(
      target: string | Addressable
    ): BaseContract & Omit<I, keyof BaseContract>;
    /**
     *  Resolves to the transaction to deploy the contract, passing %%args%%
     *  into the constructor.
     */
    getDeployTransaction(
      ...args: ContractMethodArgs<A>
    ): Promise<ContractDeployTransaction>;
    /**
     *  Resolves to the Contract deployed by passing %%args%% into the
     *  constructor.
     *
     *  This will resovle to the Contract before it has been deployed to the
     *  network, so the [[BaseContract-waitForDeployment]] should be used before
     *  sending any transactions to it.
     */
    deploy(...args: ContractMethodArgs<A>): Promise<
      BaseContract & {
        deploymentTransaction(): ContractTransactionResponse;
      } & Omit<I, keyof BaseContract>
    >;
    /**
     *  Return a new **ContractFactory** with the same ABI and bytecode,
     *  but connected to %%runner%%.
     */
    connect(runner: null | ContractRunner): ContractFactory<A, I>;
    /**
     *  Create a new **ContractFactory** from the standard Solidity JSON output.
     */
    static fromSolidity<
      A extends Array<any> = Array<any>,
      I = ContractInterface
    >(output: any, runner?: ContractRunner): ContractFactory<A, I>;
  }
  /**
   *  A Network can include an **EtherscanPlugin** to provide
   *  a custom base URL.
   *
   *  @_docloc: api/providers/thirdparty:Etherscan
   */
  export declare class EtherscanPlugin extends NetworkPlugin {
    /**
     *  The Etherscan API base URL.
     */
    readonly baseUrl: string;
    /**
     *  Creates a new **EtherscanProvider** which will use
     *  %%baseUrl%%.
     */
    constructor(baseUrl: string);
    clone(): EtherscanPlugin;
  }
  /**
   *  The **EtherscanBaseProvider** is the super-class of
   *  [[EtherscanProvider]], which should generally be used instead.
   *
   *  Since the **EtherscanProvider** includes additional code for
   *  [[Contract]] access, in //rare cases// that contracts are not
   *  used, this class can reduce code size.
   *
   *  @_docloc: api/providers/thirdparty:Etherscan
   */
  export declare class EtherscanProvider extends AbstractProvider {
    #private;
    /**
     *  The connected network.
     */
    readonly network: Network;
    /**
     *  The API key or null if using the community provided bandwidth.
     */
    readonly apiKey: null | string;
    /**
     *  Creates a new **EtherscanBaseProvider**.
     */
    constructor(_network?: Networkish, _apiKey?: string);
    /**
     *  Returns the base URL.
     *
     *  If an [[EtherscanPlugin]] is configured on the
     *  [[EtherscanBaseProvider_network]], returns the plugin's
     *  baseUrl.
     */
    getBaseUrl(): string;
    /**
     *  Returns the URL for the %%module%% and %%params%%.
     */
    getUrl(module: string, params: Record<string, string>): string;
    /**
     *  Returns the URL for using POST requests.
     */
    getPostUrl(): string;
    /**
     *  Returns the parameters for using POST requests.
     */
    getPostData(
      module: string,
      params: Record<string, any>
    ): Record<string, any>;
    detectNetwork(): Promise<Network>;
    /**
     *  Resolves to the result of calling %%module%% with %%params%%.
     *
     *  If %%post%%, the request is made as a POST request.
     */
    fetch(
      module: string,
      params: Record<string, any>,
      post?: boolean
    ): Promise<any>;
    /**
     *  Returns %%transaction%% normalized for the Etherscan API.
     */
    _getTransactionPostData(
      transaction: TransactionRequest
    ): Record<string, string>;
    /**
     *  Throws the normalized Etherscan error.
     */
    _checkError(
      req: PerformActionRequest,
      error: Error,
      transaction: any
    ): never;
    _detectNetwork(): Promise<Network>;
    _perform(req: PerformActionRequest): Promise<any>;
    getNetwork(): Promise<Network>;
    /**
     *  Resolves to the current price of ether.
     *
     *  This returns ``0`` on any network other than ``mainnet``.
     */
    getEtherPrice(): Promise<number>;
    /**
     *  Resolves to a [Contract]] for %%address%%, using the
     *  Etherscan API to retreive the Contract ABI.
     */
    getContract(_address: string): Promise<null | Contract>;
    isCommunityResource(): boolean;
  }
  /**
   *  The **InfuraWebSocketProvider** connects to the [[link-infura]]
   *  WebSocket end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-infura-signup).
   */
  export declare class InfuraWebSocketProvider
    extends WebSocketProvider
    implements CommunityResourcable
  {
    /**
     *  The Project ID for the INFURA connection.
     */
    readonly projectId: string;
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    readonly projectSecret: null | string;
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
    constructor(network?: Networkish, projectId?: string);
    isCommunityResource(): boolean;
  }
  /**
   *  The **InfuraProvider** connects to the [[link-infura]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-infura-signup).
   */
  export declare class InfuraProvider
    extends JsonRpcProvider
    implements CommunityResourcable
  {
    /**
     *  The Project ID for the INFURA connection.
     */
    readonly projectId: string;
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    readonly projectSecret: null | string;
    /**
     *  Creates a new **InfuraProvider**.
     */
    constructor(
      _network?: Networkish,
      projectId?: null | string,
      projectSecret?: null | string
    );
    _getProvider(chainId: number): AbstractProvider;
    isCommunityResource(): boolean;
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
    static getWebSocketProvider(
      network?: Networkish,
      projectId?: string
    ): InfuraWebSocketProvider;
    /**
     *  Returns a prepared request for connecting to %%network%%
     *  with %%projectId%% and %%projectSecret%%.
     */
    static getRequest(
      network: Network,
      projectId?: null | string,
      projectSecret?: null | string
    ): FetchRequest;
  }
  /**
   *  The **PocketProvider** connects to the [[link-pocket]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-pocket-signup).
   */
  export declare class PocketProvider
    extends JsonRpcProvider
    implements CommunityResourcable
  {
    /**
     *  The Application ID for the Pocket connection.
     */
    readonly applicationId: string;
    /**
     *  The Application Secret for making authenticated requests
     *  to the Pocket connection.
     */
    readonly applicationSecret: null | string;
    /**
     *  Create a new **PocketProvider**.
     *
     *  By default connecting to ``mainnet`` with a highly throttled
     *  API key.
     */
    constructor(
      _network?: Networkish,
      applicationId?: null | string,
      applicationSecret?: null | string
    );
    _getProvider(chainId: number): AbstractProvider;
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%applicationId%%.
     */
    static getRequest(
      network: Network,
      applicationId?: null | string,
      applicationSecret?: null | string
    ): FetchRequest;
    isCommunityResource(): boolean;
  }
  /**
   *  The **QuickNodeProvider** connects to the [[link-quicknode]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API token is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-quicknode).
   */
  export declare class QuickNodeProvider
    extends JsonRpcProvider
    implements CommunityResourcable
  {
    /**
     *  The API token.
     */
    readonly token: string;
    /**
     *  Creates a new **QuickNodeProvider**.
     */
    constructor(_network?: Networkish, token?: null | string);
    _getProvider(chainId: number): AbstractProvider;
    isCommunityResource(): boolean;
    /**
     *  Returns a new request prepared for %%network%% and the
     *  %%token%%.
     */
    static getRequest(network: Network, token?: null | string): FetchRequest;
  }
  /**
   *  An **IpcSocketProvider** connects over an IPC socket on the host
   *  which provides fast access to the node, but requires the node and
   *  the script run on the same machine.
   */
  export declare class IpcSocketProvider extends SocketProvider {
    #private;
    /**
     *  The connected socket.
     */
    get socket(): Socket;
    constructor(path: string, network?: Networkish);
    destroy(): void;
    _write(message: string): Promise<void>;
  }
  /**
   *  An environments implementation of ``getUrl`` must return this type.
   */
  export type GetUrlResponse = {
    statusCode: number;
    statusMessage: string;
    headers: Record<string, string>;
    body: null | Uint8Array;
  };
  /**
   *  This can be used to control how throttling is handled in
   *  [[FetchRequest-setThrottleParams]].
   */
  export type FetchThrottleParams = {
    maxAttempts?: number;
    slotInterval?: number;
  };
  /**
   *  Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.
   */
  export type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;
  /**
   *  Called on the response, allowing client-based throttling logic or post-processing.
   */
  export type FetchProcessFunc = (
    req: FetchRequest,
    resp: FetchResponse
  ) => Promise<FetchResponse>;
  /**
   *  Called prior to each retry; return true to retry, false to abort.
   */
  export type FetchRetryFunc = (
    req: FetchRequest,
    resp: FetchResponse,
    attempt: number
  ) => Promise<boolean>;
  /**
   *  Called on Gateway URLs.
   */
  export type FetchGatewayFunc = (
    url: string,
    signal?: FetchCancelSignal
  ) => Promise<FetchRequest | FetchResponse>;
  /**
   *  Used to perform a fetch; use this to override the underlying network
   *  fetch layer. In NodeJS, the default uses the "http" and "https" libraries
   *  and in the browser ``fetch`` is used. If you wish to use Axios, this is
   *  how you would register it.
   */
  export type FetchGetUrlFunc = (
    req: FetchRequest,
    signal?: FetchCancelSignal
  ) => Promise<GetUrlResponse>;
  /**
   *  @_ignore
   */
  export declare class FetchCancelSignal {
    #private;
    constructor(request: FetchRequest);
    addListener(listener: () => void): void;
    get cancelled(): boolean;
    checkSignal(): void;
  }
  /**
   *  Represents a request for a resource using a URI.
   *
   *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,
   *  and ``IPFS:``.
   *
   *  Additional schemes can be added globally using [[registerGateway]].
   *
   *  @example:
   *    req = new FetchRequest("https://www.ricmoo.com")
   *    resp = await req.send()
   *    resp.body.length
   *    //_result:
   */
  export declare class FetchRequest
    implements Iterable<[key: string, value: string]>
  {
    #private;
    /**
     *  The fetch URI to requrest.
     */
    get url(): string;
    set url(url: string);
    /**
     *  The fetch body, if any, to send as the request body. //(default: null)//
     *
     *  When setting a body, the intrinsic ``Content-Type`` is automatically
     *  set and will be used if **not overridden** by setting a custom
     *  header.
     *
     *  If %%body%% is null, the body is cleared (along with the
     *  intrinsic ``Content-Type``) and the .
     *
     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to
     *  ``text/plain``.
     *
     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to
     *  ``application/octet-stream``.
     *
     *  If %%body%% is any other object, the intrincis ``Content-Type`` is
     *  set to ``application/json``.
     */
    get body(): null | Uint8Array;
    set body(body: null | string | Readonly<object> | Readonly<Uint8Array>);
    /**
     *  Returns true if the request has a body.
     */
    hasBody(): this is FetchRequest & {
      body: Uint8Array;
    };
    /**
     *  The HTTP method to use when requesting the URI. If no method
     *  has been explicitly set, then ``GET`` is used if the body is
     *  null and ``POST`` otherwise.
     */
    get method(): string;
    set method(method: null | string);
    /**
     *  The headers that will be used when requesting the URI. All
     *  keys are lower-case.
     *
     *  This object is a copy, so any chnages will **NOT** be reflected
     *  in the ``FetchRequest``.
     *
     *  To set a header entry, use the ``setHeader`` method.
     */
    get headers(): Record<string, string>;
    /**
     *  Get the header for %%key%%, ignoring case.
     */
    getHeader(key: string): string;
    /**
     *  Set the header for %%key%% to %%value%%. All values are coerced
     *  to a string.
     */
    setHeader(key: string, value: string | number): void;
    /**
     *  Clear all headers, resetting all intrinsic headers.
     */
    clearHeaders(): void;
    [Symbol.iterator](): Iterator<[key: string, value: string]>;
    /**
     *  The value that will be sent for the ``Authorization`` header.
     *
     *  To set the credentials, use the ``setCredentials`` method.
     */
    get credentials(): null | string;
    /**
     *  Sets an ``Authorization`` for %%username%% with %%password%%.
     */
    setCredentials(username: string, password: string): void;
    /**
     *  Enable and request gzip-encoded responses. The response will
     *  automatically be decompressed. //(default: true)//
     */
    get allowGzip(): boolean;
    set allowGzip(value: boolean);
    /**
     *  Allow ``Authentication`` credentials to be sent over insecure
     *  channels. //(default: false)//
     */
    get allowInsecureAuthentication(): boolean;
    set allowInsecureAuthentication(value: boolean);
    /**
     *  The timeout (in milliseconds) to wait for a complere response.
     *  //(default: 5 minutes)//
     */
    get timeout(): number;
    set timeout(timeout: number);
    /**
     *  This function is called prior to each request, for example
     *  during a redirection or retry in case of server throttling.
     *
     *  This offers an opportunity to populate headers or update
     *  content before sending a request.
     */
    get preflightFunc(): null | FetchPreflightFunc;
    set preflightFunc(preflight: null | FetchPreflightFunc);
    /**
     *  This function is called after each response, offering an
     *  opportunity to provide client-level throttling or updating
     *  response data.
     *
     *  Any error thrown in this causes the ``send()`` to throw.
     *
     *  To schedule a retry attempt (assuming the maximum retry limit
     *  has not been reached), use [[response.throwThrottleError]].
     */
    get processFunc(): null | FetchProcessFunc;
    set processFunc(process: null | FetchProcessFunc);
    /**
     *  This function is called on each retry attempt.
     */
    get retryFunc(): null | FetchRetryFunc;
    set retryFunc(retry: null | FetchRetryFunc);
    /**
     *  Create a new FetchRequest instance with default values.
     *
     *  Once created, each property may be set before issuing a
     *  ``.send()`` to make the request.
     */
    constructor(url: string);
    toString(): string;
    /**
     *  Update the throttle parameters used to determine maximum
     *  attempts and exponential-backoff properties.
     */
    setThrottleParams(params: FetchThrottleParams): void;
    /**
     *  Resolves to the response by sending the request.
     */
    send(): Promise<FetchResponse>;
    /**
     *  Cancels the inflight response, causing a ``CANCELLED``
     *  error to be rejected from the [[send]].
     */
    cancel(): void;
    /**
     *  Returns a new [[FetchRequest]] that represents the redirection
     *  to %%location%%.
     */
    redirect(location: string): FetchRequest;
    /**
     *  Create a new copy of this request.
     */
    clone(): FetchRequest;
    /**
     *  Locks all static configuration for gateways and FetchGetUrlFunc
     *  registration.
     */
    static lockConfig(): void;
    /**
     *  Get the current Gateway function for %%scheme%%.
     */
    static getGateway(scheme: string): null | FetchGatewayFunc;
    /**
     *  Use the %%func%% when fetching URIs using %%scheme%%.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
    static registerGateway(scheme: string, func: FetchGatewayFunc): void;
    /**
     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
    static registerGetUrl(getUrl: FetchGetUrlFunc): void;
    /**
     *  Creates a function that can "fetch" data URIs.
     *
     *  Note that this is automatically done internally to support
     *  data URIs, so it is not necessary to register it.
     *
     *  This is not generally something that is needed, but may
     *  be useful in a wrapper to perfom custom data URI functionality.
     */
    static createDataGateway(): FetchGatewayFunc;
    /**
     *  Creates a function that will fetch IPFS (unvalidated) from
     *  a custom gateway baseUrl.
     *
     *  The default IPFS gateway used internally is
     *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
     */
    static createIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc;
  }
  /**
   *  The response for a FetchREquest.
   */
  export declare class FetchResponse
    implements Iterable<[key: string, value: string]>
  {
    #private;
    toString(): string;
    /**
     *  The response status code.
     */
    get statusCode(): number;
    /**
     *  The response status message.
     */
    get statusMessage(): string;
    /**
     *  The response headers. All keys are lower-case.
     */
    get headers(): Record<string, string>;
    /**
     *  The response body, or ``null`` if there was no body.
     */
    get body(): null | Readonly<Uint8Array>;
    /**
     *  The response body as a UTF-8 encoded string, or the empty
     *  string (i.e. ``""``) if there was no body.
     *
     *  An error is thrown if the body is invalid UTF-8 data.
     */
    get bodyText(): string;
    /**
     *  The response body, decoded as JSON.
     *
     *  An error is thrown if the body is invalid JSON-encoded data
     *  or if there was no body.
     */
    get bodyJson(): any;
    [Symbol.iterator](): Iterator<[key: string, value: string]>;
    constructor(
      statusCode: number,
      statusMessage: string,
      headers: Readonly<Record<string, string>>,
      body: null | Uint8Array,
      request?: FetchRequest
    );
    /**
     *  Return a Response with matching headers and body, but with
     *  an error status code (i.e. 599) and %%message%% with an
     *  optional %%error%%.
     */
    makeServerError(message?: string, error?: Error): FetchResponse;
    /**
     *  If called within a [request.processFunc](FetchRequest-processFunc)
     *  call, causes the request to retry as if throttled for %%stall%%
     *  milliseconds.
     */
    throwThrottleError(message?: string, stall?: number): never;
    /**
     *  Get the header value for %%key%%, ignoring case.
     */
    getHeader(key: string): string;
    /**
     *  Returns true of the response has a body.
     */
    hasBody(): this is FetchResponse & {
      body: Uint8Array;
    };
    /**
     *  The request made for this response.
     */
    get request(): null | FetchRequest;
    /**
     *  Returns true if this response was a success statusCode.
     */
    ok(): boolean;
    /**
     *  Throws a ``SERVER_ERROR`` if this response is not ok.
     */
    assertOk(): void;
  }
  /**
   *  An error may contain additional properties, but those must not
   *  conflict with any impliciat properties.
   */
  export type ErrorInfo<T> = Omit<T, "code" | "name" | "message">;
  /**
   *  All errors emitted by ethers have an **ErrorCode** to help
   *  identify and coalesce errors to simplfy programatic analysis.
   *
   *  Each **ErrorCode** is the %%code%% proerty of a coresponding
   *  [[EthersError]].
   *
   *  **Generic Errors**
   *
   *  **``"UNKNOWN_ERROR"``** - see [[UnknownError]]
   *
   *  **``"NOT_IMPLEMENTED"``** - see [[NotImplementedError]]
   *
   *  **``"UNSUPPORTED_OPERATION"``** - see [[UnsupportedOperationError]]
   *
   *  **``"NETWORK_ERROR"``** - see [[NetworkError]]
   *
   *  **``"SERVER_ERROR"``** - see [[ServerError]]
   *
   *  **``"TIMEOUT"``** - see [[TimeoutError]]
   *
   *  **``"BAD_DATA"``** - see [[BadDataError]]
   *
   *  **``"CANCELLED"``** - see [[CancelledError]]
   *
   *  **Operational Errors**
   *
   *  **``"BUFFER_OVERRUN"``** - see [[BufferOverrunError]]
   *
   *  **``"NUMERIC_FAULT"``** - see [[NumericFaultError]]
   *
   *  **Argument Errors**
   *
   *  **``"INVALID_ARGUMENT"``** - see [[InvalidArgumentError]]
   *
   *  **``"MISSING_ARGUMENT"``** - see [[MissingArgumentError]]
   *
   *  **``"UNEXPECTED_ARGUMENT"``** - see [[UnexpectedArgumentError]]
   *
   *  **``"VALUE_MISMATCH"``** - //unused//
   *
   *  **Blockchain Errors**
   *
   *  **``"CALL_EXCEPTION"``** - see [[CallExceptionError]]
   *
   *  **``"INSUFFICIENT_FUNDS"``** - see [[InsufficientFundsError]]
   *
   *  **``"NONCE_EXPIRED"``** - see [[NonceExpiredError]]
   *
   *  **``"REPLACEMENT_UNDERPRICED"``** - see [[ReplacementUnderpricedError]]
   *
   *  **``"TRANSACTION_REPLACED"``** - see [[TransactionReplacedError]]
   *
   *  **``"UNCONFIGURED_NAME"``** - see [[UnconfiguredNameError]]
   *
   *  **``"OFFCHAIN_FAULT"``** - see [[OffchainFaultError]]
   *
   *  **User Interaction Errors**
   *
   *  **``"ACTION_REJECTED"``** - see [[ActionRejectedError]]
   */
  export type ErrorCode =
    | "UNKNOWN_ERROR"
    | "NOT_IMPLEMENTED"
    | "UNSUPPORTED_OPERATION"
    | "NETWORK_ERROR"
    | "SERVER_ERROR"
    | "TIMEOUT"
    | "BAD_DATA"
    | "CANCELLED"
    | "BUFFER_OVERRUN"
    | "NUMERIC_FAULT"
    | "INVALID_ARGUMENT"
    | "MISSING_ARGUMENT"
    | "UNEXPECTED_ARGUMENT"
    | "VALUE_MISMATCH"
    | "CALL_EXCEPTION"
    | "INSUFFICIENT_FUNDS"
    | "NONCE_EXPIRED"
    | "REPLACEMENT_UNDERPRICED"
    | "TRANSACTION_REPLACED"
    | "UNCONFIGURED_NAME"
    | "OFFCHAIN_FAULT"
    | "ACTION_REJECTED";
  /**
   *  All errors in Ethers include properties to assist in
   *  machine-readable errors.
   */
  export interface EthersError<T extends ErrorCode = ErrorCode> extends Error {
    /**
     *  The string error code.
     */
    code: ErrorCode;
    /**
     *  Additional info regarding the error that may be useful.
     *
     *  This is generally helpful mostly for human-based debugging.
     */
    info?: Record<string, any>;
    /**
     *  Any related error.
     */
    error?: Error;
  }
  /**
   *  This Error is a catch-all for when there is no way for Ethers to
   *  know what the underlying problem is.
   */
  export interface UnknownError extends EthersError<"UNKNOWN_ERROR"> {
    [key: string]: any;
  }
  /**
   *  This Error is mostly used as a stub for functionality that is
   *  intended for the future, but is currently not implemented.
   */
  export interface NotImplementedError extends EthersError<"NOT_IMPLEMENTED"> {
    /**
     *  The attempted operation.
     */
    operation: string;
  }
  /**
   *  This Error indicates that the attempted operation is not supported.
   *
   *  This could range from a specifc JSON-RPC end-point not supporting
   *  a feature to a specific configuration of an object prohibiting the
   *  operation.
   *
   *  For example, a [[Wallet]] with no connected [[Provider]] is unable
   *  to send a transaction.
   */
  export interface UnsupportedOperationError
    extends EthersError<"UNSUPPORTED_OPERATION"> {
    /**
     *  The attempted operation.
     */
    operation: string;
  }
  /**
   *  This Error indicates a proplem connecting to a network.
   */
  export interface NetworkError extends EthersError<"NETWORK_ERROR"> {
    /**
     *  The network event.
     */
    event: string;
  }
  /**
   *  This Error indicates there was a problem fetching a resource from
   *  a server.
   */
  export interface ServerError extends EthersError<"SERVER_ERROR"> {
    /**
     *  The requested resource.
     */
    request: FetchRequest | string;
    /**
     *  The response received from the server, if available.
     */
    response?: FetchResponse;
  }
  /**
   *  This Error indicates that the timeout duration has expired and
   *  that the operation has been implicitly cancelled.
   *
   *  The side-effect of the operation may still occur, as this
   *  generally means a request has been sent and there has simply
   *  been no response to indicate whether it was processed or not.
   */
  export interface TimeoutError extends EthersError<"TIMEOUT"> {
    /**
     *  The attempted operation.
     */
    operation: string;
    /**
     *  The reason.
     */
    reason: string;
    /**
     *  The resource request, if available.
     */
    request?: FetchRequest;
  }
  /**
   *  This Error indicates that a provided set of data cannot
   *  be correctly interpretted.
   */
  export interface BadDataError extends EthersError<"BAD_DATA"> {
    /**
     *  The data.
     */
    value: any;
  }
  /**
   *  This Error indicates that the operation was cancelled by a
   *  programmatic call, for example to ``cancel()``.
   */
  export interface CancelledError extends EthersError<"CANCELLED"> {}
  /**
   *  This Error indicates an attempt was made to read outside the bounds
   *  of protected data.
   *
   *  Most operations in Ethers are protected by bounds checks, to mitigate
   *  exploits when parsing data.
   */
  export interface BufferOverrunError extends EthersError<"BUFFER_OVERRUN"> {
    /**
     *  The buffer that was overrun.
     */
    buffer: Uint8Array;
    /**
     *  The length of the buffer.
     */
    length: number;
    /**
     *  The offset that was requested.
     */
    offset: number;
  }
  /**
   *  This Error indicates an operation which would result in incorrect
   *  arithmetic output has occurred.
   *
   *  For example, trying to divide by zero or using a ``uint8`` to store
   *  a negative value.
   */
  export interface NumericFaultError extends EthersError<"NUMERIC_FAULT"> {
    /**
     *  The attempted operation.
     */
    operation: string;
    /**
     *  The fault reported.
     */
    fault: string;
    /**
     *  The value the operation was attempted against.
     */
    value: any;
  }
  /**
   *  This Error indicates an incorrect type or value was passed to
   *  a function or method.
   */
  export interface InvalidArgumentError
    extends EthersError<"INVALID_ARGUMENT"> {
    /**
     *  The name of the argument.
     */
    argument: string;
    /**
     *  The value that was provided.
     */
    value: any;
    info?: Record<string, any>;
  }
  /**
   *  This Error indicates there were too few arguments were provided.
   */
  export interface MissingArgumentError
    extends EthersError<"MISSING_ARGUMENT"> {
    /**
     *  The number of arguments received.
     */
    count: number;
    /**
     *  The number of arguments expected.
     */
    expectedCount: number;
  }
  /**
   *  This Error indicates too many arguments were provided.
   */
  export interface UnexpectedArgumentError
    extends EthersError<"UNEXPECTED_ARGUMENT"> {
    /**
     *  The number of arguments received.
     */
    count: number;
    /**
     *  The number of arguments expected.
     */
    expectedCount: number;
  }
  /**
   *  The action that resulted in the error.
   */
  export type CallExceptionAction =
    | "call"
    | "estimateGas"
    | "getTransactionResult"
    | "unknown";
  /**
   *  The related transaction that caused the error.
   */
  export type CallExceptionTransaction = {
    to: null | string;
    from?: string;
    data: string;
  };
  /**
   *  This **Error** indicates a transaction reverted.
   */
  export interface CallExceptionError extends EthersError<"CALL_EXCEPTION"> {
    /**
     *  The action being performed when the revert was encountered.
     */
    action: CallExceptionAction;
    /**
     *  The revert data returned.
     */
    data: null | string;
    /**
     *  A human-readable representation of data, if possible.
     */
    reason: null | string;
    /**
     *  The transaction that triggered the exception.
     */
    transaction: CallExceptionTransaction;
    /**
     *  The contract invocation details, if available.
     */
    invocation: null | {
      method: string;
      signature: string;
      args: Array<any>;
    };
    /**
     *  The built-in or custom revert error, if available
     */
    revert: null | {
      signature: string;
      name: string;
      args: Array<any>;
    };
  }
  /**
   *  The sending account has insufficient funds to cover the
   *  entire transaction cost.
   */
  export interface InsufficientFundsError
    extends EthersError<"INSUFFICIENT_FUNDS"> {
    /**
     *  The transaction.
     */
    transaction: TransactionRequest;
  }
  /**
   *  The sending account has already used this nonce in a
   *  transaction that has been included.
   */
  export interface NonceExpiredError extends EthersError<"NONCE_EXPIRED"> {
    /**
     *  The transaction.
     */
    transaction: TransactionRequest;
  }
  /**
   *  A CCIP-read exception, which cannot be recovered from or
   *  be further processed.
   */
  export interface OffchainFaultError extends EthersError<"OFFCHAIN_FAULT"> {
    /**
     *  The transaction.
     */
    transaction?: TransactionRequest;
    /**
     *  The reason the CCIP-read failed.
     */
    reason: string;
  }
  /**
   *  An attempt was made to replace a transaction, but with an
   *  insufficient additional fee to afford evicting the old
   *  transaction from the memory pool.
   */
  export interface ReplacementUnderpricedError
    extends EthersError<"REPLACEMENT_UNDERPRICED"> {
    /**
     *  The transaction.
     */
    transaction: TransactionRequest;
  }
  /**
   *  A pending transaction was replaced by another.
   */
  export interface TransactionReplacedError
    extends EthersError<"TRANSACTION_REPLACED"> {
    /**
     *  If the transaction was cancelled, such that the original
     *  effects of the transaction cannot be assured.
     */
    cancelled: boolean;
    /**
     *  The reason the transaction was replaced.
     */
    reason: "repriced" | "cancelled" | "replaced";
    /**
     *  The hash of the replaced transaction.
     */
    hash: string;
    /**
     *  The transaction that replaced the transaction.
     */
    replacement: TransactionResponse;
    /**
     *  The receipt of the transaction that replace the transaction.
     */
    receipt: TransactionReceipt;
  }
  /**
   *  This Error indicates an ENS name was used, but the name has not
   *  been configured.
   *
   *  This could indicate an ENS name is unowned or that the current
   *  address being pointed to is the [[ZeroAddress]].
   */
  export interface UnconfiguredNameError
    extends EthersError<"UNCONFIGURED_NAME"> {
    /**
     *  The ENS name that was requested
     */
    value: string;
  }
  /**
   *  This Error indicates a request was rejected by the user.
   *
   *  In most clients (such as MetaMask), when an operation requires user
   *  authorization (such as ``signer.sendTransaction``), the client
   *  presents a dialog box to the user. If the user denies the request
   *  this error is thrown.
   */
  export interface ActionRejectedError extends EthersError<"ACTION_REJECTED"> {
    /**
     *  The requested action.
     */
    action:
      | "requestAccess"
      | "sendTransaction"
      | "signMessage"
      | "signTransaction"
      | "signTypedData"
      | "unknown";
    /**
     *  The reason the action was rejected.
     *
     *  If there is already a pending request, some clients may indicate
     *  there is already a ``"pending"`` action. This prevents an app
     *  from spamming the user.
     */
    reason: "expired" | "rejected" | "pending";
  }
  /**
   *  A conditional type that transforms the [[ErrorCode]] T into
   *  its EthersError type.
   *
   *  @flatworm-skip-docs
   */
  export type CodedEthersError<T> = T extends "UNKNOWN_ERROR"
    ? UnknownError
    : T extends "NOT_IMPLEMENTED"
    ? NotImplementedError
    : T extends "UNSUPPORTED_OPERATION"
    ? UnsupportedOperationError
    : T extends "NETWORK_ERROR"
    ? NetworkError
    : T extends "SERVER_ERROR"
    ? ServerError
    : T extends "TIMEOUT"
    ? TimeoutError
    : T extends "BAD_DATA"
    ? BadDataError
    : T extends "CANCELLED"
    ? CancelledError
    : T extends "BUFFER_OVERRUN"
    ? BufferOverrunError
    : T extends "NUMERIC_FAULT"
    ? NumericFaultError
    : T extends "INVALID_ARGUMENT"
    ? InvalidArgumentError
    : T extends "MISSING_ARGUMENT"
    ? MissingArgumentError
    : T extends "UNEXPECTED_ARGUMENT"
    ? UnexpectedArgumentError
    : T extends "CALL_EXCEPTION"
    ? CallExceptionError
    : T extends "INSUFFICIENT_FUNDS"
    ? InsufficientFundsError
    : T extends "NONCE_EXPIRED"
    ? NonceExpiredError
    : T extends "OFFCHAIN_FAULT"
    ? OffchainFaultError
    : T extends "REPLACEMENT_UNDERPRICED"
    ? ReplacementUnderpricedError
    : T extends "TRANSACTION_REPLACED"
    ? TransactionReplacedError
    : T extends "UNCONFIGURED_NAME"
    ? UnconfiguredNameError
    : T extends "ACTION_REJECTED"
    ? ActionRejectedError
    : never;
  /**
   *  Returns true if the %%error%% matches an error thrown by ethers
   *  that matches the error %%code%%.
   *
   *  In TypeScript envornoments, this can be used to check that %%error%%
   *  matches an EthersError type, which means the expected properties will
   *  be set.
   *
   *  @See [ErrorCodes](api:ErrorCode)
   *  @example
   *    try {
   *      // code....
   *    } catch (e) {
   *      if (isError(e, "CALL_EXCEPTION")) {
   *          // The Type Guard has validated this object
   *          console.log(e.data);
   *      }
   *    }
   */
  export declare function isError<
    K extends ErrorCode,
    T extends CodedEthersError<K>
  >(error: any, code: K): error is T;
  /**
   *  Returns true if %%error%% is a [[CallExceptionError].
   */
  export declare function isCallException(
    error: any
  ): error is CallExceptionError;
  /**
   *  Returns a new Error configured to the format ethers emits errors, with
   *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties
   *  for the corresponding EthersError.
   *
   *  Each error in ethers includes the version of ethers, a
   *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional
   *  required properties. The error message will also include the %%meeage%%,
   *  ethers version, %%code%% and all aditional properties, serialized.
   */
  export declare function makeError<
    K extends ErrorCode,
    T extends CodedEthersError<K>
  >(message: string, code: K, info?: ErrorInfo<T>): T;
  /**
   *  Throws an EthersError with %%message%%, %%code%% and additional error
   *  %%info%% when %%check%% is falsish..
   *
   *  @see [[api:makeError]]
   */
  export declare function assert<
    K extends ErrorCode,
    T extends CodedEthersError<K>
  >(
    check: unknown,
    message: string,
    code: K,
    info?: ErrorInfo<T>
  ): asserts check;
  /**
   *  A simple helper to simply ensuring provided arguments match expected
   *  constraints, throwing if not.
   *
   *  In TypeScript environments, the %%check%% has been asserted true, so
   *  any further code does not need additional compile-time checks.
   */
  export declare function assertArgument(
    check: unknown,
    message: string,
    name: string,
    value: unknown
  ): asserts check;
  export declare function assertArgumentCount(
    count: number,
    expectedCount: number,
    message?: string
  ): void;
  /**
   *  Throws if the normalization %%form%% is not supported.
   */
  export declare function assertNormalize(form: string): void;
  /**
   *  Many classes use file-scoped values to guard the constructor,
   *  making it effectively private. This facilitates that pattern
   *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
   *  throwing if not, indicating the %%className%% if provided.
   */
  export declare function assertPrivate(
    givenGuard: any,
    guard: any,
    className?: string
  ): void;
  /**
   *  A callback function called when a an event is triggered.
   */
  export type Listener = (...args: Array<any>) => void;
  /**
   *  An **EventEmitterable** behaves similar to an EventEmitter
   *  except provides async access to its methods.
   *
   *  An EventEmitter implements the observer pattern.
   */
  export interface EventEmitterable<T> {
    /**
     *  Registers a %%listener%% that is called whenever the
     *  %%event%% occurs until unregistered.
     */
    on(event: T, listener: Listener): Promise<this>;
    /**
     *  Registers a %%listener%% that is called the next time
     *  %%event%% occurs.
     */
    once(event: T, listener: Listener): Promise<this>;
    /**
     *  Triggers each listener for %%event%% with the %%args%%.
     */
    emit(event: T, ...args: Array<any>): Promise<boolean>;
    /**
     *  Resolves to the number of listeners for %%event%%.
     */
    listenerCount(event?: T): Promise<number>;
    /**
     *  Resolves to the listeners for %%event%%.
     */
    listeners(event?: T): Promise<Array<Listener>>;
    /**
     *  Unregister the %%listener%% for %%event%%. If %%listener%%
     *  is unspecified, all listeners are unregistered.
     */
    off(event: T, listener?: Listener): Promise<this>;
    /**
     *  Unregister all listeners for %%event%%.
     */
    removeAllListeners(event?: T): Promise<this>;
    /**
     *  Alias for [[on]].
     */
    addListener(event: T, listener: Listener): Promise<this>;
    /**
     *  Alias for [[off]].
     */
    removeListener(event: T, listener: Listener): Promise<this>;
  }
  /**
   *  When an [[EventEmitterable]] triggers a [[Listener]], the
   *  callback always ahas one additional argument passed, which is
   *  an **EventPayload**.
   */
  export declare class EventPayload<T> {
    #private;
    /**
     *  The event filter.
     */
    readonly filter: T;
    /**
     *  The **EventEmitterable**.
     */
    readonly emitter: EventEmitterable<T>;
    /**
     *  Create a new **EventPayload** for %%emitter%% with
     *  the %%listener%% and for %%filter%%.
     */
    constructor(
      emitter: EventEmitterable<T>,
      listener: null | Listener,
      filter: T
    );
    /**
     *  Unregister the triggered listener for future events.
     */
    removeListener(): Promise<void>;
  }
  /**
   *  A description of a fixed-point arithmetic field.
   *
   *  When specifying the fixed format, the values override the default of
   *  a ``fixed128x18``, which implies a signed 128-bit value with 18
   *  decimals of precision.
   *
   *  The alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and
   *  ``ufixed128x18`` respectively.
   *
   *  When a fixed format string begins with a ``u``, it indicates the field
   *  is unsigned, so any negative values will overflow. The first number
   *  indicates the bit-width and the second number indicates the decimal
   *  precision.
   *
   *  When a ``number`` is used for a fixed format, it indicates the number
   *  of decimal places, and the default width and signed-ness will be used.
   *
   *  The bit-width must be byte aligned and the decimals can be at most 80.
   */
  export type FixedFormat =
    | number
    | string
    | {
        signed?: boolean;
        width?: number;
        decimals?: number;
      };
  /**
   *  A FixedNumber represents a value over its [[FixedFormat]]
   *  arithmetic field.
   *
   *  A FixedNumber can be used to perform math, losslessly, on
   *  values which have decmial places.
   *
   *  A FixedNumber has a fixed bit-width to store values in, and stores all
   *  values internally by multiplying the value by 10 raised to the power of
   *  %%decimals%%.
   *
   *  If operations are performed that cause a value to grow too high (close to
   *  positive infinity) or too low (close to negative infinity), the value
   *  is said to //overflow//.
   *
   *  For example, an 8-bit signed value, with 0 decimals may only be within
   *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become
   *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.
   *
   *  Many operation have a normal and //unsafe// variant. The normal variant
   *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//
   *  variant will silently allow overflow, corrupting its value value.
   *
   *  If operations are performed that cause a value to become too small
   *  (close to zero), the value loses precison and is said to //underflow//.
   *
   *  For example, an value with 1 decimal place may store a number as small
   *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit
   *  into 1 decimal place, so underflow occurs which means precision is lost
   *  and the value becomes ``0``.
   *
   *  Some operations have a normal and //signalling// variant. The normal
   *  variant will silently ignore underflow, while the //signalling// variant
   *  will thow a [[NumericFaultError]] on underflow.
   */
  export declare class FixedNumber {
    #private;
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    readonly format: string;
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    readonly _value: string;
    /**
     *  @private
     */
    constructor(guard: any, value: bigint, format: any);
    /**
     *  If true, negative values are permitted, otherwise only
     *  positive values and zero are allowed.
     */
    get signed(): boolean;
    /**
     *  The number of bits available to store the value.
     */
    get width(): number;
    /**
     *  The number of decimal places in the fixed-point arithment field.
     */
    get decimals(): number;
    /**
     *  The value as an integer, based on the smallest unit the
     *  [[decimals]] allow.
     */
    get value(): bigint;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%, ignoring overflow.
     */
    addUnsafe(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    add(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%, ignoring overflow.
     */
    subUnsafe(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    sub(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%, ignoring overflow and underflow (precision loss).
     */
    mulUnsafe(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
    mul(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs or if underflow (precision loss) occurs.
     */
    mulSignal(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    divUnsafe(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    div(other: FixedNumber): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
     *  (precision loss) occurs.
     */
    divSignal(other: FixedNumber): FixedNumber;
    /**
     *  Returns a comparison result between %%this%% and %%other%%.
     *
     *  This is suitable for use in sorting, where ``-1`` implies %%this%%
     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
     *  both are equal.
     */
    cmp(other: FixedNumber): number;
    /**
     *  Returns true if %%other%% is equal to %%this%%.
     */
    eq(other: FixedNumber): boolean;
    /**
     *  Returns true if %%other%% is less than to %%this%%.
     */
    lt(other: FixedNumber): boolean;
    /**
     *  Returns true if %%other%% is less than or equal to %%this%%.
     */
    lte(other: FixedNumber): boolean;
    /**
     *  Returns true if %%other%% is greater than to %%this%%.
     */
    gt(other: FixedNumber): boolean;
    /**
     *  Returns true if %%other%% is greater than or equal to %%this%%.
     */
    gte(other: FixedNumber): boolean;
    /**
     *  Returns a new [[FixedNumber]] which is the largest **integer**
     *  that is less than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
    floor(): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] which is the smallest **integer**
     *  that is greater than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
    ceiling(): FixedNumber;
    /**
     *  Returns a new [[FixedNumber]] with the decimal component
     *  rounded up on ties at %%decimals%% places.
     */
    round(decimals?: number): FixedNumber;
    /**
     *  Returns true if %%this%% is equal to ``0``.
     */
    isZero(): boolean;
    /**
     *  Returns true if %%this%% is less than ``0``.
     */
    isNegative(): boolean;
    /**
     *  Returns the string representation of %%this%%.
     */
    toString(): string;
    /**
     *  Returns a float approximation.
     *
     *  Due to IEEE 754 precission (or lack thereof), this function
     *  can only return an approximation and most values will contain
     *  rounding errors.
     */
    toUnsafeFloat(): number;
    /**
     *  Return a new [[FixedNumber]] with the same value but has had
     *  its field set to %%format%%.
     *
     *  This will throw if the value cannot fit into %%format%%.
     */
    toFormat(format: FixedFormat): FixedNumber;
    /**
     *  Creates a new [[FixedNumber]] for %%value%% divided by
     *  %%decimal%% places with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
     *  or underflow (precision loss).
     */
    static fromValue(
      _value: BigNumberish,
      _decimals?: Numeric,
      _format?: FixedFormat
    ): FixedNumber;
    /**
     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%%, either due to overflow or underflow (precision loss).
     */
    static fromString(_value: string, _format?: FixedFormat): FixedNumber;
    /**
     *  Creates a new [[FixedNumber]] with the big-endian representation
     *  %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%% due to overflow.
     */
    static fromBytes(_value: BytesLike, _format?: FixedFormat): FixedNumber;
  }
  /**
   *  Any type that can be used where a numeric value is needed.
   */
  export type Numeric = number | bigint;
  /**
   *  Any type that can be used where a big number is needed.
   */
  export type BigNumberish = string | Numeric;
  /**
   *  Convert %%value%% from a twos-compliment representation of %%width%%
   *  bits to its value.
   *
   *  If the highest bit is ``1``, the result will be negative.
   */
  export declare function fromTwos(
    _value: BigNumberish,
    _width: Numeric
  ): bigint;
  /**
   *  Convert %%value%% to a twos-compliment representation of
   *  %%width%% bits.
   *
   *  The result will always be positive.
   */
  export declare function toTwos(_value: BigNumberish, _width: Numeric): bigint;
  /**
   *  Mask %%value%% with a bitmask of %%bits%% ones.
   */
  export declare function mask(_value: BigNumberish, _bits: Numeric): bigint;
  /**
   *  Gets a BigInt from %%value%%. If it is an invalid value for
   *  a BigInt, then an ArgumentError will be thrown for %%name%%.
   */
  export declare function getBigInt(value: BigNumberish, name?: string): bigint;
  /**
   *  Returns %%value%% as a bigint, validating it is valid as a bigint
   *  value and that it is positive.
   */
  export declare function getUint(value: BigNumberish, name?: string): bigint;
  export declare function toBigInt(value: BigNumberish | Uint8Array): bigint;
  /**
   *  Gets a //number// from %%value%%. If it is an invalid value for
   *  a //number//, then an ArgumentError will be thrown for %%name%%.
   */
  export declare function getNumber(value: BigNumberish, name?: string): number;
  /**
   *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
   *  is treated as Big Endian data. Throws if the value is not safe.
   */
  export declare function toNumber(value: BigNumberish | Uint8Array): number;
  /**
   *  Converts %%value%% to a Big Endian hexstring, optionally padded to
   *  %%width%% bytes.
   */
  export declare function toBeHex(
    _value: BigNumberish,
    _width?: Numeric
  ): string;
  /**
   *  Converts %%value%% to a Big Endian Uint8Array.
   */
  export declare function toBeArray(_value: BigNumberish): Uint8Array;
  /**
   *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.
   *
   *  A //Quantity// does not have and leading 0 values unless the value is
   *  the literal value `0x0`. This is most commonly used for JSSON-RPC
   *  numeric values.
   */
  export declare function toQuantity(value: BytesLike | BigNumberish): string;
  /**
   *  Property helper functions.
   *
   *  @_subsection api/utils:Properties  [about-properties]
   */
  /**
   *  Resolves to a new object that is a copy of %%value%%, but with all
   *  values resolved.
   */
  export declare function resolveProperties<T>(value: {
    [P in keyof T]: T[P] | Promise<T[P]>;
  }): Promise<T>;
  /**
   *  Assigns the %%values%% to %%target%% as read-only values.
   *
   *  It %%types%% is specified, the values are checked.
   */
  export declare function defineProperties<T>(
    target: T,
    values: {
      [K in keyof T]?: T[K];
    },
    types?: {
      [K in keyof T]?: string;
    }
  ): void;
  /**
   *  Decodes %%data%% into the structured data it represents.
   */
  export declare function decodeRlp(_data: BytesLike): RlpStructuredData;
  /**
   *  An RLP-encoded structure.
   */
  export type RlpStructuredData = string | Array<RlpStructuredData>;
  /**
   *  Encodes %%object%% as an RLP-encoded [[DataHexString]].
   */
  export declare function encodeRlp(object: RlpStructuredData): string;
  /**
   *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal
   *  places. The %%unit%% may be the number of decimal places or the name of
   *  a unit (e.g. ``"gwei"`` for 9 decimal places).
   *
   */
  export declare function formatUnits(
    value: BigNumberish,
    unit?: string | Numeric
  ): string;
  /**
   *  Converts the //decimal string// %%value%% to a BigInt, assuming
   *  %%unit%% decimal places. The %%unit%% may the number of decimal places
   *  or the name of a unit (e.g. ``"gwei"`` for 9 decimal places).
   */
  export declare function parseUnits(
    value: string,
    unit?: string | Numeric
  ): bigint;
  /**
   *  Converts %%value%% into a //decimal string// using 18 decimal places.
   */
  export declare function formatEther(wei: BigNumberish): string;
  /**
   *  Converts the //decimal string// %%ether%% to a BigInt, using 18
   *  decimal places.
   */
  export declare function parseEther(ether: string): bigint;
  /**
   *  The stanard normalization forms.
   */
  export type UnicodeNormalizationForm = "NFC" | "NFD" | "NFKC" | "NFKD";
  /**
   *  When using the UTF-8 error API the following errors can be intercepted
   *  and processed as the %%reason%% passed to the [[Utf8ErrorFunc]].
   *
   *  **``"UNEXPECTED_CONTINUE"``** - a continuation byte was present where there
   *  was nothing to continue.
   *
   *  **``"BAD_PREFIX"``** - an invalid (non-continuation) byte to start a
   *  UTF-8 codepoint was found.
   *
   *  **``"OVERRUN"``** - the string is too short to process the expected
   *  codepoint length.
   *
   *  **``"MISSING_CONTINUE"``** - a missing continuation byte was expected but
   *  not found. The %%offset%% indicates the index the continuation byte
   *  was expected at.
   *
   *  **``"OUT_OF_RANGE"``** - the computed code point is outside the range
   *  for UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was
   *  outside the valid UTF-8 range.
   *
   *  **``"UTF16_SURROGATE"``** - the UTF-8 strings contained a UTF-16 surrogate
   *  pair. The %%badCodepoint%% is the computed codepoint, which was inside the
   *  UTF-16 surrogate range.
   *
   *  **``"OVERLONG"``** - the string is an overlong representation. The
   *  %%badCodepoint%% indicates the computed codepoint, which has already
   *  been bounds checked.
   *
   *
   *  @returns string
   */
  export type Utf8ErrorReason =
    | "UNEXPECTED_CONTINUE"
    | "BAD_PREFIX"
    | "OVERRUN"
    | "MISSING_CONTINUE"
    | "OUT_OF_RANGE"
    | "UTF16_SURROGATE"
    | "OVERLONG";
  /**
   *  A callback that can be used with [[toUtf8String]] to analysis or
   *  recovery from invalid UTF-8 data.
   *
   *  Parsing UTF-8 data is done through a simple Finite-State Machine (FSM)
   *  which calls the ``Utf8ErrorFunc`` if a fault is detected.
   *
   *  The %%reason%% indicates where in the FSM execution the fault
   *  occurred and the %%offset%% indicates where the input failed.
   *
   *  The %%bytes%% represents the raw UTF-8 data that was provided and
   *  %%output%% is the current array of UTF-8 code-points, which may
   *  be updated by the ``Utf8ErrorFunc``.
   *
   *  The value of the %%badCodepoint%% depends on the %%reason%%. See
   *  [[Utf8ErrorReason]] for details.
   *
   *  The function should return the number of bytes that should be skipped
   *  when control resumes to the FSM.
   */
  export type Utf8ErrorFunc = (
    reason: Utf8ErrorReason,
    offset: number,
    bytes: Uint8Array,
    output: Array<number>,
    badCodepoint?: number
  ) => number;
  /**
   *  A handful of popular, built-in UTF-8 error handling strategies.
   *
   *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
   *  non-canonical (overlong) codepoints (this is the default)
   *
   *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
   *  and accepts non-canonical (overlong) codepoints
   *
   *  **``"replace"``** - replace any illegal UTF-8 sequence with the
   *  UTF-8 replacement character (i.e. ``"\\ufffd"``) and accepts
   *  non-canonical (overlong) codepoints
   *
   *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
   */
  export declare const Utf8ErrorFuncs: Readonly<
    Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
  >;
  /**
   *  Returns the UTF-8 byte representation of %%str%%.
   *
   *  If %%form%% is specified, the string is normalized.
   */
  export declare function toUtf8Bytes(
    str: string,
    form?: UnicodeNormalizationForm
  ): Uint8Array;
  /**
   *  Returns the string represented by the UTF-8 data %%bytes%%.
   *
   *  When %%onError%% function is specified, it is called on UTF-8
   *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
   *  (default: [error](Utf8ErrorFuncs))
   */
  export declare function toUtf8String(
    bytes: BytesLike,
    onError?: Utf8ErrorFunc
  ): string;
  /**
   *  Returns the UTF-8 code-points for %%str%%.
   *
   *  If %%form%% is specified, the string is normalized.
   */
  export declare function toUtf8CodePoints(
    str: string,
    form?: UnicodeNormalizationForm
  ): Array<number>;
  /**
   *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.
   *
   *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
   */
  export declare function uuidV4(randomBytes: BytesLike): string;
  /**
   *  A [[Result]] is a sub-class of Array, which allows accessing any
   *  of its values either positionally by its index or, if keys are
   *  provided by its name.
   *
   *  @_docloc: api/abi
   */
  export declare class Result extends Array<any> {
    #private;
    [K: string | number]: any;
    /**
     *  @private
     */
    constructor(...args: Array<any>);
    /**
     *  Returns the Result as a normal Array.
     *
     *  This will throw if there are any outstanding deferred
     *  errors.
     */
    toArray(): Array<any>;
    /**
     *  Returns the Result as an Object with each name-value pair.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
    toObject(): Record<string, any>;
    /**
     *  @_ignore
     */
    slice(start?: number | undefined, end?: number | undefined): Result;
    /**
     *  @_ignore
     */
    filter(
      callback: (el: any, index: number, array: Result) => boolean,
      thisArg?: any
    ): Result;
    /**
     *  @_ignore
     */
    map<T extends any = any>(
      callback: (el: any, index: number, array: Result) => T,
      thisArg?: any
    ): Array<T>;
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
    getValue(name: string): any;
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
    static fromItems(items: Array<any>, keys?: Array<null | string>): Result;
  }
  /**
   *  Returns all errors found in a [[Result]].
   *
   *  Since certain errors encountered when creating a [[Result]] do
   *  not impact the ability to continue parsing data, they are
   *  deferred until they are actually accessed. Hence a faulty string
   *  in an Event that is never used does not impact the program flow.
   *
   *  However, sometimes it may be useful to access, identify or
   *  validate correctness of a [[Result]].
   *
   *  @_docloc api/abi
   */
  export declare function checkResultErrors(result: Result): Array<{
    path: Array<string | number>;
    error: Error;
  }>;
  /**
   *  A fragment is a single item from an ABI, which may represent any of:
   *
   *  - [Functions](FunctionFragment)
   *  - [Events](EventFragment)
   *  - [Constructors](ConstructorFragment)
   *  - Custom [Errors](ErrorFragment)
   *  - [Fallback or Receive](FallbackFragment) functions
   *
   *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
   */
  /**
   *  A Type description in a [JSON ABI format](link-solc-jsonabi).
   */
  export interface JsonFragmentType {
    /**
     *  The parameter name.
     */
    readonly name?: string;
    /**
     *  If the parameter is indexed.
     */
    readonly indexed?: boolean;
    /**
     *  The type of the parameter.
     */
    readonly type?: string;
    /**
     *  The internal Solidity type.
     */
    readonly internalType?: string;
    /**
     *  The components for a tuple.
     */
    readonly components?: ReadonlyArray<JsonFragmentType>;
  }
  /**
   *  A fragment for a method, event or error in a [JSON ABI format](link-solc-jsonabi).
   */
  export interface JsonFragment {
    /**
     *  The name of the error, event, function, etc.
     */
    readonly name?: string;
    /**
     *  The type of the fragment (e.g. ``event``, ``"function"``, etc.)
     */
    readonly type?: string;
    /**
     *  If the event is anonymous.
     */
    readonly anonymous?: boolean;
    /**
     *  If the function is payable.
     */
    readonly payable?: boolean;
    /**
     *  If the function is constant.
     */
    readonly constant?: boolean;
    /**
     *  The mutability state of the function.
     */
    readonly stateMutability?: string;
    /**
     *  The input parameters.
     */
    readonly inputs?: ReadonlyArray<JsonFragmentType>;
    /**
     *  The output parameters.
     */
    readonly outputs?: ReadonlyArray<JsonFragmentType>;
    /**
     *  The gas limit to use when sending a transaction for this function.
     */
    readonly gas?: string;
  }
  /**
   *  The format to serialize the output as.
   *
   *  **``"sighash"``** - the bare formatting, used to compute the selector
   *  or topic hash; this format cannot be reversed (as it discards ``indexed``)
   *  so cannot by used to export an [[Interface]].
   *
   *  **``"minimal"``** - Human-Readable ABI with minimal spacing and without
   *  names, so it is compact, but will result in Result objects that cannot
   *  be accessed by name.
   *
   *  **``"full"``** - Full Human-Readable ABI, with readable spacing and names
   *  intact; this is generally the recommended format.
   *
   *  **``"json"``** - The [JSON ABI format](link-solc-jsonabi).
   */
  export type FormatType = "sighash" | "minimal" | "full" | "json";
  /**
   *  When [walking](ParamType-walk) a [[ParamType]], this is called
   *  on each component.
   */
  export type ParamTypeWalkFunc = (type: string, value: any) => any;
  /**
   *  When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],
   *  this is called on each component.
   */
  export type ParamTypeWalkAsyncFunc = (
    type: string,
    value: any
  ) => any | Promise<any>;
  /**
   *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
   */
  export declare class ParamType {
    #private;
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    readonly name: string;
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    readonly type: string;
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    readonly baseType: string;
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    readonly indexed: null | boolean;
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    readonly components: null | ReadonlyArray<ParamType>;
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    readonly arrayLength: null | number;
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    readonly arrayChildren: null | ParamType;
    /**
     *  @private
     */
    constructor(
      guard: any,
      name: string,
      type: string,
      baseType: string,
      indexed: null | boolean,
      components: null | ReadonlyArray<ParamType>,
      arrayLength: null | number,
      arrayChildren: null | ParamType
    );
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    format(format?: FormatType): string;
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
    isArray(): this is ParamType & {
      arrayChildren: ParamType;
      arrayLength: number;
    };
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
    isTuple(): this is ParamType & {
      components: ReadonlyArray<ParamType>;
    };
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
    isIndexable(): this is ParamType & {
      indexed: boolean;
    };
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
    walk(value: any, process: ParamTypeWalkFunc): any;
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS naes by walking and resolving each
     *  ``"address"`` type.
     */
    walkAsync(value: any, process: ParamTypeWalkAsyncFunc): Promise<any>;
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    static from(obj: any, allowIndexed?: boolean): ParamType;
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
    static isParamType(value: any): value is ParamType;
  }
  /**
   *  The type of a [[Fragment]].
   */
  export type FragmentType =
    | "constructor"
    | "error"
    | "event"
    | "fallback"
    | "function"
    | "struct";
  /**
   *  An abstract class to represent An individual fragment from a parse ABI.
   */
  export declare abstract class Fragment {
    /**
     *  The type of the fragment.
     */
    readonly type: FragmentType;
    /**
     *  The inputs for the fragment.
     */
    readonly inputs: ReadonlyArray<ParamType>;
    /**
     *  @private
     */
    constructor(
      guard: any,
      type: FragmentType,
      inputs: ReadonlyArray<ParamType>
    );
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    abstract format(format?: FormatType): string;
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    static from(obj: any): Fragment;
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
    static isConstructor(value: any): value is ConstructorFragment;
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
    static isError(value: any): value is ErrorFragment;
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
    static isEvent(value: any): value is EventFragment;
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
    static isFunction(value: any): value is FunctionFragment;
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
    static isStruct(value: any): value is StructFragment;
  }
  /**
   *  An abstract class to represent An individual fragment
   *  which has a name from a parse ABI.
   */
  export declare abstract class NamedFragment extends Fragment {
    /**
     *  The name of the fragment.
     */
    readonly name: string;
    /**
     *  @private
     */
    constructor(
      guard: any,
      type: FragmentType,
      name: string,
      inputs: ReadonlyArray<ParamType>
    );
  }
  /**
   *  A Fragment which represents a //Custom Error//.
   */
  export declare class ErrorFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>);
    /**
     *  The Custom Error selector.
     */
    get selector(): string;
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    format(format?: FormatType): string;
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
    static from(obj: any): ErrorFragment;
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
    static isFragment(value: any): value is ErrorFragment;
  }
  /**
   *  A Fragment which represents an Event.
   */
  export declare class EventFragment extends NamedFragment {
    /**
     *  Whether this event is anonymous.
     */
    readonly anonymous: boolean;
    /**
     *  @private
     */
    constructor(
      guard: any,
      name: string,
      inputs: ReadonlyArray<ParamType>,
      anonymous: boolean
    );
    /**
     *  The Event topic hash.
     */
    get topicHash(): string;
    /**
     *  Returns a string representation of this event as %%format%%.
     */
    format(format?: FormatType): string;
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
    static getTopicHash(name: string, params?: Array<any>): string;
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
    static from(obj: any): EventFragment;
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
    static isFragment(value: any): value is EventFragment;
  }
  /**
   *  A Fragment which represents a constructor.
   */
  export declare class ConstructorFragment extends Fragment {
    /**
     *  Whether the constructor can receive an endowment.
     */
    readonly payable: boolean;
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    readonly gas: null | bigint;
    /**
     *  @private
     */
    constructor(
      guard: any,
      type: FragmentType,
      inputs: ReadonlyArray<ParamType>,
      payable: boolean,
      gas: null | bigint
    );
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    format(format?: FormatType): string;
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
    static from(obj: any): ConstructorFragment;
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
    static isFragment(value: any): value is ConstructorFragment;
  }
  /**
   *  A Fragment which represents a method.
   */
  export declare class FallbackFragment extends Fragment {
    /**
     *  If the function can be sent value during invocation.
     */
    readonly payable: boolean;
    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean);
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    format(format?: FormatType): string;
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
    static from(obj: any): FallbackFragment;
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
    static isFragment(value: any): value is FallbackFragment;
  }
  /**
   *  A Fragment which represents a method.
   */
  export declare class FunctionFragment extends NamedFragment {
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    readonly constant: boolean;
    /**
     *  The returned types for the result of calling this function.
     */
    readonly outputs: ReadonlyArray<ParamType>;
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    readonly stateMutability: "payable" | "nonpayable" | "view" | "pure";
    /**
     *  If the function can be sent value during invocation.
     */
    readonly payable: boolean;
    /**
     *  The recommended gas limit to send when calling this function.
     */
    readonly gas: null | bigint;
    /**
     *  @private
     */
    constructor(
      guard: any,
      name: string,
      stateMutability: "payable" | "nonpayable" | "view" | "pure",
      inputs: ReadonlyArray<ParamType>,
      outputs: ReadonlyArray<ParamType>,
      gas: null | bigint
    );
    /**
     *  The Function selector.
     */
    get selector(): string;
    /**
     *  Returns a string representation of this function as %%format%%.
     */
    format(format?: FormatType): string;
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
    static getSelector(name: string, params?: Array<any>): string;
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
    static from(obj: any): FunctionFragment;
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
    static isFragment(value: any): value is FunctionFragment;
  }
  /**
   *  A Fragment which represents a structure.
   */
  export declare class StructFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>);
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    format(): string;
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
    static from(obj: any): StructFragment;
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
    static isFragment(value: any): value is FunctionFragment;
  }
  /**
   *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
   *  values into binary data and decoding binary data into JavaScript values.
   */
  export declare class AbiCoder {
    #private;
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result;
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encode(
      types: ReadonlyArray<string | ParamType>,
      values: ReadonlyArray<any>
    ): string;
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
    decode(
      types: ReadonlyArray<string | ParamType>,
      data: BytesLike,
      loose?: boolean
    ): Result;
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
    static defaultAbiCoder(): AbiCoder;
    /**
     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
     *  result %%data%% for the [[CallExceptionAction]] %%action%% against
     *  the Transaction %%tx%%.
     */
    static getBuiltinCallException(
      action: CallExceptionAction,
      tx: {
        to?: null | string;
        from?: null | string;
        data?: string;
      },
      data: null | BytesLike
    ): CallExceptionError;
  }
  /**
   *  Encodes %%text%% as a Bytes32 string.
   */
  export declare function encodeBytes32String(text: string): string;
  /**
   *  Encodes the Bytes32-encoded %%bytes%% into a string.
   */
  export declare function decodeBytes32String(_bytes: BytesLike): string;
  /**
   *  A **Typed** that represents a numeric value.
   */
  export interface TypedBigInt extends Typed {
    /**
     *  The value.
     */
    value: bigint;
    /**
     *  The default value for all numeric types is ``0``.
     */
    defaultValue(): bigint;
    /**
     *  The minimum value for this type, accounting for bit-width and signed-ness.
     */
    minValue(): bigint;
    /**
     *  The minimum value for this type, accounting for bit-width.
     */
    maxValue(): bigint;
  }
  /**
   *  A **Typed** that represents a binary sequence of data as bytes.
   */
  export interface TypedData extends Typed {
    /**
     *  The value.
     */
    value: string;
    /**
     *  The default value for this type.
     */
    defaultValue(): string;
  }
  /**
   *  A **Typed** that represents a UTF-8 sequence of bytes.
   */
  export interface TypedString extends Typed {
    /**
     *  The value.
     */
    value: string;
    /**
     *  The default value for the string type is the empty string (i.e. ``""``).
     */
    defaultValue(): string;
  }
  /**
   *  The **Typed** class to wrap values providing explicit type information.
   */
  export declare class Typed {
    #private;
    /**
     *  The type, as a Solidity-compatible type.
     */
    readonly type: string;
    /**
     *  The actual value.
     */
    readonly value: any;
    /**
     *  @_ignore:
     */
    readonly _typedSymbol: Symbol;
    /**
     *  @_ignore:
     */
    constructor(gaurd: any, type: string, value: any, options?: any);
    /**
     *  Format the type as a Human-Readable type.
     */
    format(): string;
    /**
     *  The default value returned by this type.
     */
    defaultValue(): string | number | bigint | Result;
    /**
     *  The minimum value for numeric types.
     */
    minValue(): string | number | bigint;
    /**
     *  The maximum value for numeric types.
     */
    maxValue(): string | number | bigint;
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
     */
    isBigInt(): this is TypedBigInt;
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
     */
    isData(): this is TypedData;
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
     */
    isString(): this is TypedString;
    /**
     *  Returns the tuple name, if this is a tuple. Throws otherwise.
     */
    get tupleName(): null | string;
    /**
     *  Returns the length of the array type or ``-1`` if it is dynamic.
     *
     *  Throws if the type is not an array.
     */
    get arrayLength(): null | number;
    /**
     *  Returns a new **Typed** of %%type%% with the %%value%%.
     */
    static from(type: string, value: any): Typed;
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static uint8(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint16`` type for %%v%%.
     */
    static uint16(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint24`` type for %%v%%.
     */
    static uint24(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint32`` type for %%v%%.
     */
    static uint32(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint40`` type for %%v%%.
     */
    static uint40(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint48`` type for %%v%%.
     */
    static uint48(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint56`` type for %%v%%.
     */
    static uint56(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint64`` type for %%v%%.
     */
    static uint64(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint72`` type for %%v%%.
     */
    static uint72(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint80`` type for %%v%%.
     */
    static uint80(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint88`` type for %%v%%.
     */
    static uint88(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint96`` type for %%v%%.
     */
    static uint96(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint104`` type for %%v%%.
     */
    static uint104(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint112`` type for %%v%%.
     */
    static uint112(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint120`` type for %%v%%.
     */
    static uint120(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint128`` type for %%v%%.
     */
    static uint128(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint136`` type for %%v%%.
     */
    static uint136(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint144`` type for %%v%%.
     */
    static uint144(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint152`` type for %%v%%.
     */
    static uint152(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint160`` type for %%v%%.
     */
    static uint160(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint168`` type for %%v%%.
     */
    static uint168(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint176`` type for %%v%%.
     */
    static uint176(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint184`` type for %%v%%.
     */
    static uint184(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint192`` type for %%v%%.
     */
    static uint192(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint200`` type for %%v%%.
     */
    static uint200(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint208`` type for %%v%%.
     */
    static uint208(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint216`` type for %%v%%.
     */
    static uint216(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint224`` type for %%v%%.
     */
    static uint224(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint232`` type for %%v%%.
     */
    static uint232(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint240`` type for %%v%%.
     */
    static uint240(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint248`` type for %%v%%.
     */
    static uint248(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint256(v: BigNumberish): Typed;
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
    static uint(v: BigNumberish): Typed;
    /**
     *  Return a new ``int8`` type for %%v%%.
     */
    static int8(v: BigNumberish): Typed;
    /**
     *  Return a new ``int16`` type for %%v%%.
     */
    static int16(v: BigNumberish): Typed;
    /**
     *  Return a new ``int24`` type for %%v%%.
     */
    static int24(v: BigNumberish): Typed;
    /**
     *  Return a new ``int32`` type for %%v%%.
     */
    static int32(v: BigNumberish): Typed;
    /**
     *  Return a new ``int40`` type for %%v%%.
     */
    static int40(v: BigNumberish): Typed;
    /**
     *  Return a new ``int48`` type for %%v%%.
     */
    static int48(v: BigNumberish): Typed;
    /**
     *  Return a new ``int56`` type for %%v%%.
     */
    static int56(v: BigNumberish): Typed;
    /**
     *  Return a new ``int64`` type for %%v%%.
     */
    static int64(v: BigNumberish): Typed;
    /**
     *  Return a new ``int72`` type for %%v%%.
     */
    static int72(v: BigNumberish): Typed;
    /**
     *  Return a new ``int80`` type for %%v%%.
     */
    static int80(v: BigNumberish): Typed;
    /**
     *  Return a new ``int88`` type for %%v%%.
     */
    static int88(v: BigNumberish): Typed;
    /**
     *  Return a new ``int96`` type for %%v%%.
     */
    static int96(v: BigNumberish): Typed;
    /**
     *  Return a new ``int104`` type for %%v%%.
     */
    static int104(v: BigNumberish): Typed;
    /**
     *  Return a new ``int112`` type for %%v%%.
     */
    static int112(v: BigNumberish): Typed;
    /**
     *  Return a new ``int120`` type for %%v%%.
     */
    static int120(v: BigNumberish): Typed;
    /**
     *  Return a new ``int128`` type for %%v%%.
     */
    static int128(v: BigNumberish): Typed;
    /**
     *  Return a new ``int136`` type for %%v%%.
     */
    static int136(v: BigNumberish): Typed;
    /**
     *  Return a new ``int144`` type for %%v%%.
     */
    static int144(v: BigNumberish): Typed;
    /**
     *  Return a new ``int52`` type for %%v%%.
     */
    static int152(v: BigNumberish): Typed;
    /**
     *  Return a new ``int160`` type for %%v%%.
     */
    static int160(v: BigNumberish): Typed;
    /**
     *  Return a new ``int168`` type for %%v%%.
     */
    static int168(v: BigNumberish): Typed;
    /**
     *  Return a new ``int176`` type for %%v%%.
     */
    static int176(v: BigNumberish): Typed;
    /**
     *  Return a new ``int184`` type for %%v%%.
     */
    static int184(v: BigNumberish): Typed;
    /**
     *  Return a new ``int92`` type for %%v%%.
     */
    static int192(v: BigNumberish): Typed;
    /**
     *  Return a new ``int200`` type for %%v%%.
     */
    static int200(v: BigNumberish): Typed;
    /**
     *  Return a new ``int208`` type for %%v%%.
     */
    static int208(v: BigNumberish): Typed;
    /**
     *  Return a new ``int216`` type for %%v%%.
     */
    static int216(v: BigNumberish): Typed;
    /**
     *  Return a new ``int224`` type for %%v%%.
     */
    static int224(v: BigNumberish): Typed;
    /**
     *  Return a new ``int232`` type for %%v%%.
     */
    static int232(v: BigNumberish): Typed;
    /**
     *  Return a new ``int240`` type for %%v%%.
     */
    static int240(v: BigNumberish): Typed;
    /**
     *  Return a new ``int248`` type for %%v%%.
     */
    static int248(v: BigNumberish): Typed;
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int256(v: BigNumberish): Typed;
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
    static int(v: BigNumberish): Typed;
    /**
     *  Return a new ``bytes1`` type for %%v%%.
     */
    static bytes1(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes2`` type for %%v%%.
     */
    static bytes2(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes3`` type for %%v%%.
     */
    static bytes3(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes4`` type for %%v%%.
     */
    static bytes4(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes5`` type for %%v%%.
     */
    static bytes5(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes6`` type for %%v%%.
     */
    static bytes6(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes7`` type for %%v%%.
     */
    static bytes7(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes8`` type for %%v%%.
     */
    static bytes8(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes9`` type for %%v%%.
     */
    static bytes9(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes10`` type for %%v%%.
     */
    static bytes10(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes11`` type for %%v%%.
     */
    static bytes11(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes12`` type for %%v%%.
     */
    static bytes12(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes13`` type for %%v%%.
     */
    static bytes13(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes14`` type for %%v%%.
     */
    static bytes14(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes15`` type for %%v%%.
     */
    static bytes15(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes16`` type for %%v%%.
     */
    static bytes16(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes17`` type for %%v%%.
     */
    static bytes17(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes18`` type for %%v%%.
     */
    static bytes18(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes19`` type for %%v%%.
     */
    static bytes19(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes20`` type for %%v%%.
     */
    static bytes20(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes21`` type for %%v%%.
     */
    static bytes21(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes22`` type for %%v%%.
     */
    static bytes22(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes23`` type for %%v%%.
     */
    static bytes23(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes24`` type for %%v%%.
     */
    static bytes24(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes25`` type for %%v%%.
     */
    static bytes25(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes26`` type for %%v%%.
     */
    static bytes26(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes27`` type for %%v%%.
     */
    static bytes27(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes28`` type for %%v%%.
     */
    static bytes28(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes29`` type for %%v%%.
     */
    static bytes29(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes30`` type for %%v%%.
     */
    static bytes30(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes31`` type for %%v%%.
     */
    static bytes31(v: BytesLike): Typed;
    /**
     *  Return a new ``bytes32`` type for %%v%%.
     */
    static bytes32(v: BytesLike): Typed;
    /**
     *  Return a new ``address`` type for %%v%%.
     */
    static address(v: string | Addressable): Typed;
    /**
     *  Return a new ``bool`` type for %%v%%.
     */
    static bool(v: any): Typed;
    /**
     *  Return a new ``bytes`` type for %%v%%.
     */
    static bytes(v: BytesLike): Typed;
    /**
     *  Return a new ``string`` type for %%v%%.
     */
    static string(v: string): Typed;
    /**
     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
     */
    static array(v: Array<any | Typed>, dynamic?: null | boolean): Typed;
    /**
     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
     */
    static tuple(
      v: Array<any | Typed> | Record<string, any | Typed>,
      name?: string
    ): Typed;
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
    static overrides(v: Record<string, any>): Typed;
    /**
     *  Returns true only if %%value%% is a [[Typed]] instance.
     */
    static isTyped(value: any): value is Typed;
    /**
     *  If the value is a [[Typed]] instance, validates the underlying value
     *  and returns it, otherwise returns value directly.
     *
     *  This is useful for functions that with to accept either a [[Typed]]
     *  object or values.
     */
    static dereference<T>(value: Typed | T, type: string): T;
  }
  /**
   *  When using the [[Interface-parseLog]] to automatically match a Log to its event
   *  for parsing, a **LogDescription** is returned.
   */
  export declare class LogDescription {
    /**
     *  The matching fragment for the ``topic0``.
     */
    readonly fragment: EventFragment;
    /**
     *  The name of the Event.
     */
    readonly name: string;
    /**
     *  The full Event signature.
     */
    readonly signature: string;
    /**
     *  The topic hash for the Event.
     */
    readonly topic: string;
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    readonly args: Result;
    /**
     *  @_ignore:
     */
    constructor(fragment: EventFragment, topic: string, args: Result);
  }
  /**
   *  When using the [[Interface-parseTransaction]] to automatically match
   *  a transaction data to its function for parsing,
   *  a **TransactionDescription** is returned.
   */
  export declare class TransactionDescription {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    readonly fragment: FunctionFragment;
    /**
     *  The name of the Function from the transaction ``data``.
     */
    readonly name: string;
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    readonly args: Result;
    /**
     *  The full Function signature from the transaction ``data``.
     */
    readonly signature: string;
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    readonly selector: string;
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    readonly value: bigint;
    /**
     *  @_ignore:
     */
    constructor(
      fragment: FunctionFragment,
      selector: string,
      args: Result,
      value: bigint
    );
  }
  /**
   *  When using the [[Interface-parseError]] to automatically match an
   *  error for a call result for parsing, an **ErrorDescription** is returned.
   */
  export declare class ErrorDescription {
    /**
     *  The matching fragment.
     */
    readonly fragment: ErrorFragment;
    /**
     *  The name of the Error.
     */
    readonly name: string;
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    readonly args: Result;
    /**
     *  The full Error signature.
     */
    readonly signature: string;
    /**
     *  The selector for the Error.
     */
    readonly selector: string;
    /**
     *  @_ignore:
     */
    constructor(fragment: ErrorFragment, selector: string, args: Result);
  }
  /**
   *  An **Indexed** is used as a value when a value that does not
   *  fit within a topic (i.e. not a fixed-length, 32-byte type). It
   *  is the ``keccak256`` of the value, and used for types such as
   *  arrays, tuples, bytes and strings.
   */
  export declare class Indexed {
    /**
     *  The ``keccak256`` of the value logged.
     */
    readonly hash: null | string;
    /**
     *  @_ignore:
     */
    readonly _isIndexed: boolean;
    /**
     *  Returns ``true`` if %%value%% is an **Indexed**.
     *
     *  This provides a Type Guard for property access.
     */
    static isIndexed(value: any): value is Indexed;
    /**
     *  @_ignore:
     */
    constructor(hash: null | string);
  }
  /**
   *  An **InterfaceAbi** may be any supported ABI format.
   *
   *  A string is expected to be a JSON string, which will be parsed
   *  using ``JSON.parse``. This means that the value **must** be a valid
   *  JSON string, with no stray commas, etc.
   *
   *  An array may contain any combination of:
   *  - Human-Readable fragments
   *  - Parsed JSON fragment
   *  - [[Fragment]] instances
   *
   *  A **Human-Readable Fragment** is a string which resembles a Solidity
   *  signature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).
   *  For example, ``function balanceOf(address) view returns (uint)``.
   *
   *  A **Parsed JSON Fragment** is a JavaScript Object desribed in the
   *  [Solidity documentation](link-solc-jsonabi).
   */
  export type InterfaceAbi =
    | string
    | ReadonlyArray<Fragment | JsonFragment | string>;
  /**
   *  An Interface abstracts many of the low-level details for
   *  encoding and decoding the data on the blockchain.
   *
   *  An ABI provides information on how to encode data to send to
   *  a Contract, how to decode the results and events and how to
   *  interpret revert errors.
   *
   *  The ABI can be specified by [any supported format](InterfaceAbi).
   */
  export declare class Interface {
    #private;
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    readonly fragments: ReadonlyArray<Fragment>;
    /**
     *  The Contract constructor.
     */
    readonly deploy: ConstructorFragment;
    /**
     *  The Fallback method, if any.
     */
    readonly fallback: null | FallbackFragment;
    /**
     *  If receiving ether is supported.
     */
    readonly receive: boolean;
    /**
     *  Create a new Interface for the %%fragments%%.
     */
    constructor(fragments: InterfaceAbi);
    /**
     *  Returns the entire Human-Readable ABI, as an array of
     *  signatures, optionally as %%minimal%% strings, which
     *  removes parameter names and unneceesary spaces.
     */
    format(minimal?: boolean): Array<string>;
    /**
     *  Return the JSON-encoded ABI. This is the format Solidiy
     *  returns.
     */
    formatJson(): string;
    /**
     *  The ABI coder that will be used to encode and decode binary
     *  data.
     */
    getAbiCoder(): AbiCoder;
    /**
     *  Get the function name for %%key%%, which may be a function selector,
     *  function name or function signature that belongs to the ABI.
     */
    getFunctionName(key: string): string;
    /**
     *  Returns true if %%key%% (a function selector, function name or
     *  function signature) is present in the ABI.
     *
     *  In the case of a function name, the name may be ambiguous, so
     *  accessing the [[FunctionFragment]] may require refinement.
     */
    hasFunction(key: string): boolean;
    /**
     *  Get the [[FunctionFragment]] for %%key%%, which may be a function
     *  selector, function name or function signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple functions match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single function in
     *  the ABI, this will throw.
     */
    getFunction(
      key: string,
      values?: Array<any | Typed>
    ): null | FunctionFragment;
    /**
     *  Iterate over all functions, calling %%callback%%, sorted by their name.
     */
    forEachFunction(
      callback: (func: FunctionFragment, index: number) => void
    ): void;
    /**
     *  Get the event name for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     */
    getEventName(key: string): string;
    /**
     *  Returns true if %%key%% (an event topic hash, event name or
     *  event signature) is present in the ABI.
     *
     *  In the case of an event name, the name may be ambiguous, so
     *  accessing the [[EventFragment]] may require refinement.
     */
    hasEvent(key: string): boolean;
    /**
     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple events match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single event in
     *  the ABI, this will throw.
     */
    getEvent(key: string, values?: Array<any | Typed>): null | EventFragment;
    /**
     *  Iterate over all events, calling %%callback%%, sorted by their name.
     */
    forEachEvent(callback: (func: EventFragment, index: number) => void): void;
    /**
     *  Get the [[ErrorFragment]] for %%key%%, which may be an error
     *  selector, error name or error signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple errors match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single error in
     *  the ABI, this will throw.
     */
    getError(key: string, values?: Array<any | Typed>): null | ErrorFragment;
    /**
     *  Iterate over all errors, calling %%callback%%, sorted by their name.
     */
    forEachError(callback: (func: ErrorFragment, index: number) => void): void;
    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result;
    _encodeParams(
      params: ReadonlyArray<ParamType>,
      values: ReadonlyArray<any>
    ): string;
    /**
     *  Encodes a ``tx.data`` object for deploying the Contract with
     *  the %%values%% as the constructor arguments.
     */
    encodeDeploy(values?: ReadonlyArray<any>): string;
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified error (see [[getError]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeErrorResult(
      fragment: ErrorFragment | string,
      data: BytesLike
    ): Result;
    /**
     *  Encodes the transaction revert data for a call result that
     *  reverted from the the Contract with the sepcified %%error%%
     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeErrorResult(
      fragment: ErrorFragment | string,
      values?: ReadonlyArray<any>
    ): string;
    /**
     *  Decodes the %%data%% from a transaction ``tx.data`` for
     *  the function specified (see [[getFunction]] for valid values
     *  for %%fragment%%).
     *
     *  Most developers should prefer the [[parseTransaction]] method
     *  instead, which will automatically detect the fragment.
     */
    decodeFunctionData(
      fragment: FunctionFragment | string,
      data: BytesLike
    ): Result;
    /**
     *  Encodes the ``tx.data`` for a transaction that calls the function
     *  specified (see [[getFunction]] for valid values for %%fragment%%) with
     *  the %%values%%.
     */
    encodeFunctionData(
      fragment: FunctionFragment | string,
      values?: ReadonlyArray<any>
    ): string;
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
    decodeFunctionResult(
      fragment: FunctionFragment | string,
      data: BytesLike
    ): Result;
    makeError(
      _data: BytesLike,
      tx: CallExceptionTransaction
    ): CallExceptionError;
    /**
     *  Encodes the result data (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values
     *  for %%fragment%%) with %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
    encodeFunctionResult(
      fragment: FunctionFragment | string,
      values?: ReadonlyArray<any>
    ): string;
    encodeFilterTopics(
      fragment: EventFragment | string,
      values: ReadonlyArray<any>
    ): Array<null | string | Array<string>>;
    encodeEventLog(
      fragment: EventFragment | string,
      values: ReadonlyArray<any>
    ): {
      data: string;
      topics: Array<string>;
    };
    decodeEventLog(
      fragment: EventFragment | string,
      data: BytesLike,
      topics?: ReadonlyArray<string>
    ): Result;
    /**
     *  Parses a transaction, finding the matching function and extracts
     *  the parameter values along with other useful function details.
     *
     *  If the matching function cannot be found, return null.
     */
    parseTransaction(tx: {
      data: string;
      value?: BigNumberish;
    }): null | TransactionDescription;
    parseCallResult(data: BytesLike): Result;
    /**
     *  Parses a receipt log, finding the matching event and extracts
     *  the parameter values along with other useful event details.
     *
     *  If the matching event cannot be found, returns null.
     */
    parseLog(log: {
      topics: Array<string>;
      data: string;
    }): null | LogDescription;
    /**
     *  Parses a revert data, finding the matching error and extracts
     *  the parameter values along with other useful error details.
     *
     *  If the matching event cannot be found, returns null.
     */
    parseError(data: BytesLike): null | ErrorDescription;
    /**
     *  Creates a new [[Interface]] from the ABI %%value%%.
     *
     *  The %%value%% may be provided as an existing [[Interface]] object,
     *  a JSON-encoded ABI or any Human-Readable ABI format.
     */
    static from(value: InterfaceAbi | Interface): Interface;
  }
  /**
   *  A constant for the zero address.
   *
   *  (**i.e.** ``"0x0000000000000000000000000000000000000000"``)
   */
  export declare const ZeroAddress: string;
  /**
   *  A constant for the zero hash.
   *
   *  (**i.e.** ``"0x0000000000000000000000000000000000000000000000000000000000000000"``)
   */
  export declare const ZeroHash: string;
  /**
   *  A constant for the order N for the secp256k1 curve.
   *
   *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)
   */
  export declare const N: bigint;
  /**
   *  A constant for the number of wei in a single ether.
   *
   *  (**i.e.** ``1000000000000000000n``)
   */
  export declare const WeiPerEther: bigint;
  /**
   *  A constant for the maximum value for a ``uint256``.
   *
   *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
   */
  export declare const MaxUint256: bigint;
  /**
   *  A constant for the minimum value for an ``int256``.
   *
   *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)
   */
  export declare const MinInt256: bigint;
  /**
   *  A constant for the maximum value for an ``int256``.
   *
   *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
   */
  export declare const MaxInt256: bigint;
  /**
   *  A constant for the ether symbol (normalized using NFKC).
   *
   *  (**i.e.** ``"\\u039e"``)
   */
  export declare const EtherSymbol: string;
  /**
   *  A constant for the [[link-eip-191]] personal message prefix.
   *
   *  (**i.e.** ``"\\x19Ethereum Signed Message:\\n"``)
   */
  export declare const MessagePrefix: string;
  /**
   *  The **BaseWallet** is a stream-lined implementation of a
   *  [[Signer]] that operates with a private key.
   *
   *  It is preferred to use the [[Wallet]] class, as it offers
   *  additional functionality and simplifies loading a variety
   *  of JSON formats, Mnemonic Phrases, etc.
   *
   *  This class may be of use for those attempting to implement
   *  a minimal Signer.
   */
  export declare class BaseWallet extends AbstractSigner {
    #private;
    /**
     *  The wallet address.
     */
    readonly address: string;
    /**
     *  Creates a new BaseWallet for %%privateKey%%, optionally
     *  connected to %%provider%%.
     *
     *  If %%provider%% is not specified, only offline methods can
     *  be used.
     */
    constructor(privateKey: SigningKey, provider?: null | Provider);
    /**
     *  The [[SigningKey]] used for signing payloads.
     */
    get signingKey(): SigningKey;
    /**
     *  The private key for this wallet.
     */
    get privateKey(): string;
    getAddress(): Promise<string>;
    connect(provider: null | Provider): BaseWallet;
    signTransaction(tx: TransactionRequest): Promise<string>;
    signMessage(message: string | Uint8Array): Promise<string>;
    /**
     *  Returns the signature for %%message%% signed with this wallet.
     */
    signMessageSync(message: string | Uint8Array): string;
    signTypedData(
      domain: TypedDataDomain,
      types: Record<string, Array<TypedDataField>>,
      value: Record<string, any>
    ): Promise<string>;
  }
  /**
   *  A Wordlist represents a collection of language-specific
   *  words used to encode and devoce [[link-bip-39]] encoded data
   *  by mapping words to 11-bit values and vice versa.
   */
  export declare abstract class Wordlist {
    locale: string;
    /**
     *  Creates a new Wordlist instance.
     *
     *  Sub-classes MUST call this if they provide their own constructor,
     *  passing in the locale string of the language.
     *
     *  Generally there is no need to create instances of a Wordlist,
     *  since each language-specific Wordlist creates an instance and
     *  there is no state kept internally, so they are safe to share.
     */
    constructor(locale: string);
    /**
     *  Sub-classes may override this to provide a language-specific
     *  method for spliting %%phrase%% into individual words.
     *
     *  By default, %%phrase%% is split using any sequences of
     *  white-space as defined by regular expressions (i.e. ``/\s+/``).
     */
    split(phrase: string): Array<string>;
    /**
     *  Sub-classes may override this to provider a language-specific
     *  method for joining %%words%% into a phrase.
     *
     *  By default, %%words%% are joined by a single space.
     */
    join(words: Array<string>): string;
    /**
     *  Maps an 11-bit value into its coresponding word in the list.
     *
     *  Sub-classes MUST override this.
     */
    abstract getWord(index: number): string;
    /**
     *  Maps a word to its corresponding 11-bit value.
     *
     *  Sub-classes MUST override this.
     */
    abstract getWordIndex(word: string): number;
  }
  /**
   *  An OWL format Wordlist is an encoding method that exploits
   *  the general locality of alphabetically sorted words to
   *  achieve a simple but effective means of compression.
   *
   *  This class is generally not useful to most developers as
   *  it is used mainly internally to keep Wordlists for languages
   *  based on ASCII-7 small.
   *
   *  If necessary, there are tools within the ``generation/`` folder
   *  to create the necessary data.
   */
  export declare class WordlistOwl extends Wordlist {
    #private;
    /**
     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
     *  and validated against the %%checksum%%.
     */
    constructor(locale: string, data: string, checksum: string);
    /**
     *  The OWL-encoded data.
     */
    get _data(): string;
    /**
     *  Decode all the words for the wordlist.
     */
    _decodeWords(): Array<string>;
    getWord(index: number): string;
    getWordIndex(word: string): number;
  }
  /**
   *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  export declare class LangEn extends WordlistOwl {
    /**
     *  Creates a new instance of the English language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEn]] should suffice.
     *
     *  @_ignore:
     */
    constructor();
    /**
     *  Returns a singleton instance of a ``LangEn``, creating it
     *  if this is the first time being called.
     */
    static wordlist(): LangEn;
  }
  /**
   *  An OWL-A format Wordlist extends the OWL format to add an
   *  overlay onto an OWL format Wordlist to support diacritic
   *  marks.
   *
   *  This class is generally not useful to most developers as
   *  it is used mainly internally to keep Wordlists for languages
   *  based on latin-1 small.
   *
   *  If necessary, there are tools within the ``generation/`` folder
   *  to create the necessary data.
   */
  export declare class WordlistOwlA extends WordlistOwl {
    #private;
    /**
     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
     *  and %%accent%% data and validated against the %%checksum%%.
     */
    constructor(locale: string, data: string, accent: string, checksum: string);
    /**
     *  The OWLA-encoded accent data.
     */
    get _accent(): string;
    /**
     *  Decode all the words for the wordlist.
     */
    _decodeWords(): Array<string>;
  }
  /**
   *  The available Wordlists by their
   *  [ISO 639-1 Language Code](link-wiki-iso639).
   *
   *  (**i.e.** [cz](LangCz), [en](LangEn), [es](LangEs), [fr](LangFr),
   *  [ja](LangJa), [ko](LangKo), [it](LangIt), [pt](LangPt),
   *  [zh_cn](LangZh), [zh_tw](LangZh))
   *
   *  The dist files (in the ``/dist`` folder) have had all languages
   *  except English stripped out, which reduces the library size by
   *  about 80kb. If required, they are available by importing the
   *  included ``wordlists-extra.min.js`` file.
   */
  export declare const wordlists: Record<string, Wordlist>;
  /**
   *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]
   *  seeds and convert between phrases and entropy.
   */
  export declare class Mnemonic {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    readonly phrase: string;
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    readonly password: string;
    /**
     *  The wordlist for this mnemonic.
     */
    readonly wordlist: Wordlist;
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    readonly entropy: string;
    /**
     *  @private
     */
    constructor(
      guard: any,
      entropy: string,
      phrase: string,
      password?: null | string,
      wordlist?: null | Wordlist
    );
    /**
     *  Returns the seed for the mnemonic.
     */
    computeSeed(): string;
    /**
     *  Creates a new Mnemonic for the %%phrase%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
    static fromPhrase(
      phrase: string,
      password?: null | string,
      wordlist?: null | Wordlist
    ): Mnemonic;
    /**
     *  Create a new **Mnemonic** from the %%entropy%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
    static fromEntropy(
      _entropy: BytesLike,
      password?: null | string,
      wordlist?: null | Wordlist
    ): Mnemonic;
    /**
     *  Returns the phrase for %%mnemonic%%.
     */
    static entropyToPhrase(
      _entropy: BytesLike,
      wordlist?: null | Wordlist
    ): string;
    /**
     *  Returns the entropy for %%phrase%%.
     */
    static phraseToEntropy(phrase: string, wordlist?: null | Wordlist): string;
    /**
     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
     *
     *  This checks all the provided words belong to the %%wordlist%%,
     *  that the length is valid and the checksum is correct.
     */
    static isValidMnemonic(phrase: string, wordlist?: null | Wordlist): boolean;
  }
  /**
   *  The default derivation path for Ethereum HD Nodes. (i.e. ``"m/44'/60'/0'/0/0"``)
   */
  export declare const defaultPath: string;
  /**
   *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived
   *  from an HD Node using the [[link-bip-32]] stantard.
   *
   *  An HD Node forms a hierarchal structure with each HD Node having a
   *  private key and the ability to derive child HD Nodes, defined by
   *  a path indicating the index of each child.
   */
  export declare class HDNodeWallet extends BaseWallet {
    #private;
    /**
     *  The compressed public key.
     */
    readonly publicKey: string;
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    readonly fingerprint: string;
    /**
     *  The parent fingerprint.
     */
    readonly parentFingerprint: string;
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    readonly mnemonic: null | Mnemonic;
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    readonly chainCode: string;
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    readonly path: null | string;
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    readonly index: number;
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    readonly depth: number;
    /**
     *  @private
     */
    constructor(
      guard: any,
      signingKey: SigningKey,
      parentFingerprint: string,
      chainCode: string,
      path: null | string,
      index: number,
      depth: number,
      mnemonic: null | Mnemonic,
      provider: null | Provider
    );
    connect(provider: null | Provider): HDNodeWallet;
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
    encrypt(
      password: Uint8Array | string,
      progressCallback?: ProgressCallback
    ): Promise<string>;
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
    encryptSync(password: Uint8Array | string): string;
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpriv`` and can be used to
     *  reconstruct this HD Node to derive its children.
     */
    get extendedKey(): string;
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
    hasPath(): this is {
      path: string;
    };
    /**
     *  Returns a neutered HD Node, which removes the private details
     *  of an HD Node.
     *
     *  A neutered node has no private key, but can be used to derive
     *  child addresses and other public data about the HD Node.
     */
    neuter(): HDNodeVoidWallet;
    /**
     *  Return the child for %%index%%.
     */
    deriveChild(_index: Numeric): HDNodeWallet;
    /**
     *  Return the HDNode for %%path%% from this node.
     */
    derivePath(path: string): HDNodeWallet;
    /**
     *  Creates a new HD Node from %%extendedKey%%.
     *
     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
     *  or full HD Node ([[HDNodeWallet) respectively.
     */
    static fromExtendedKey(
      extendedKey: string
    ): HDNodeWallet | HDNodeVoidWallet;
    /**
     *  Creates a new random HDNode.
     */
    static createRandom(
      password?: string,
      path?: string,
      wordlist?: Wordlist
    ): HDNodeWallet;
    /**
     *  Create an HD Node from %%mnemonic%%.
     */
    static fromMnemonic(mnemonic: Mnemonic, path?: string): HDNodeWallet;
    /**
     *  Creates an HD Node from a mnemonic %%phrase%%.
     */
    static fromPhrase(
      phrase: string,
      password?: string,
      path?: string,
      wordlist?: Wordlist
    ): HDNodeWallet;
    /**
     *  Creates an HD Node from a %%seed%%.
     */
    static fromSeed(seed: BytesLike): HDNodeWallet;
  }
  /**
   *  A **HDNodeVoidWallet** cannot sign, but provides access to
   *  the children nodes of a [[link-bip-32]] HD wallet addresses.
   *
   *  The can be created by using an extended ``xpub`` key to
   *  [[HDNodeWallet_fromExtendedKey]] or by
   *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].
   */
  export declare class HDNodeVoidWallet extends VoidSigner {
    /**
     *  The compressed public key.
     */
    readonly publicKey: string;
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    readonly fingerprint: string;
    /**
     *  The parent node fingerprint.
     */
    readonly parentFingerprint: string;
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    readonly chainCode: string;
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    readonly path: null | string;
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    readonly index: number;
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    readonly depth: number;
    /**
     *  @private
     */
    constructor(
      guard: any,
      address: string,
      publicKey: string,
      parentFingerprint: string,
      chainCode: string,
      path: null | string,
      index: number,
      depth: number,
      provider: null | Provider
    );
    connect(provider: null | Provider): HDNodeVoidWallet;
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpub`` and can be used to
     *  reconstruct this neutered key to derive its children addresses.
     */
    get extendedKey(): string;
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
    hasPath(): this is {
      path: string;
    };
    /**
     *  Return the child for %%index%%.
     */
    deriveChild(_index: Numeric): HDNodeVoidWallet;
    /**
     *  Return the signer for %%path%% from this node.
     */
    derivePath(path: string): HDNodeVoidWallet;
  }
  /**
   *  Returns the [[link-bip-32]] path for the acount at %%index%%.
   *
   *  This is the pattern used by wallets like Ledger.
   *
   *  There is also an [alternate pattern](getIndexedAccountPath) used by
   *  some software.
   */
  export declare function getAccountPath(_index: Numeric): string;
  /**
   *  Returns the path using an alternative pattern for deriving accounts,
   *  at %%index%%.
   *
   *  This derivation path uses the //index// component rather than the
   *  //account// component to derive sequential accounts.
   *
   *  This is the pattern used by wallets like MetaMask.
   */
  export declare function getIndexedAccountPath(_index: Numeric): string;
  /**
   *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
   */
  /**
   *  The data stored within a JSON Crowdsale wallet is fairly
   *  minimal.
   */
  export type CrowdsaleAccount = {
    privateKey: string;
    address: string;
  };
  /**
   *  Returns true if %%json%% is a valid JSON Crowdsale wallet.
   */
  export declare function isCrowdsaleJson(json: string): boolean;
  /**
   *  Before Ethereum launched, it was necessary to create a wallet
   *  format for backers to use, which would be used to receive ether
   *  as a reward for contributing to the project.
   *
   *  The [[link-crowdsale]] format is now obsolete, but it is still
   *  useful to support and the additional code is fairly trivial as
   *  all the primitives required are used through core portions of
   *  the library.
   */
  export declare function decryptCrowdsaleJson(
    json: string,
    _password: string | Uint8Array
  ): CrowdsaleAccount;
  /**
   *  The contents of a JSON Keystore Wallet.
   */
  export type KeystoreAccount = {
    address: string;
    privateKey: string;
    mnemonic?: {
      path?: string;
      locale?: string;
      entropy: string;
    };
  };
  /**
   *  The parameters to use when encrypting a JSON Keystore Wallet.
   */
  export type EncryptOptions = {
    progressCallback?: ProgressCallback;
    iv?: BytesLike;
    entropy?: BytesLike;
    client?: string;
    salt?: BytesLike;
    uuid?: string;
    scrypt?: {
      N?: number;
      r?: number;
      p?: number;
    };
  };
  /**
   *  Returns true if %%json%% is a valid JSON Keystore Wallet.
   */
  export declare function isKeystoreJson(json: string): boolean;
  /**
   *  Returns the account details for the JSON Keystore Wallet %%json%%
   *  using %%password%%.
   *
   *  It is preferred to use the [async version](decryptKeystoreJson)
   *  instead, which allows a [[ProgressCallback]] to keep the user informed
   *  as to the decryption status.
   *
   *  This method will block the event loop (freezing all UI) until decryption
   *  is complete, which can take quite some time, depending on the wallet
   *  paramters and platform.
   */
  export declare function decryptKeystoreJsonSync(
    json: string,
    _password: string | Uint8Array
  ): KeystoreAccount;
  /**
   *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the
   *  %%password%%.
   *
   *  If provided, %%progress%% will be called periodically during the
   *  decrpytion to provide feedback, and if the function returns
   *  ``false`` will halt decryption.
   *
   *  The %%progressCallback%% will **always** receive ``0`` before
   *  decryption begins and ``1`` when complete.
   */
  export declare function decryptKeystoreJson(
    json: string,
    _password: string | Uint8Array,
    progress?: ProgressCallback
  ): Promise<KeystoreAccount>;
  /**
   *  Return the JSON Keystore Wallet for %%account%% encrypted with
   *  %%password%%.
   *
   *  The %%options%% can be used to tune the password-based key
   *  derivation function parameters, explicitly set the random values
   *  used. Any provided [[ProgressCallback]] is ignord.
   */
  export declare function encryptKeystoreJsonSync(
    account: KeystoreAccount,
    password: string | Uint8Array,
    options?: EncryptOptions
  ): string;
  /**
   *  Resolved to the JSON Keystore Wallet for %%account%% encrypted
   *  with %%password%%.
   *
   *  The %%options%% can be used to tune the password-based key
   *  derivation function parameters, explicitly set the random values
   *  used and provide a [[ProgressCallback]] to receive periodic updates
   *  on the completion status..
   */
  export declare function encryptKeystoreJson(
    account: KeystoreAccount,
    password: string | Uint8Array,
    options?: EncryptOptions
  ): Promise<string>;
  /**
   *  A **Wallet** manages a single private key which is used to sign
   *  transactions, messages and other common payloads.
   *
   *  This class is generally the main entry point for developers
   *  that wish to use a private key directly, as it can create
   *  instances from a large variety of common sources, including
   *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON
   *  wallets.
   */
  export declare class Wallet extends BaseWallet {
    #private;
    /**
     *  Create a new wallet for the %%privateKey%%, optionally connected
     *  to %%provider%%.
     */
    constructor(key: string | SigningKey, provider?: null | Provider);
    connect(provider: null | Provider): Wallet;
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
    encrypt(
      password: Uint8Array | string,
      progressCallback?: ProgressCallback
    ): Promise<string>;
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
    encryptSync(password: Uint8Array | string): string;
    /**
     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
     *  with %%password%%.
     *
     *  If %%progress%% is provided, it is called periodically during
     *  decryption so that any UI can be updated.
     */
    static fromEncryptedJson(
      json: string,
      password: Uint8Array | string,
      progress?: ProgressCallback
    ): Promise<HDNodeWallet | Wallet>;
    /**
     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
     *
     *  The [[fromEncryptedJson]] method is preferred, as this method
     *  will lock up and freeze the UI during decryption, which may take
     *  some time.
     */
    static fromEncryptedJsonSync(
      json: string,
      password: Uint8Array | string
    ): HDNodeWallet | Wallet;
    /**
     *  Creates a new random [[HDNodeWallet]] using the avavilable
     *  [cryptographic random source](randomBytes).
     *
     *  If there is no crytographic random source, this will throw.
     */
    static createRandom(provider?: null | Provider): HDNodeWallet;
    /**
     *  Creates a [[HDNodeWallet]] for %%phrase%%.
     */
    static fromPhrase(phrase: string, provider?: Provider): HDNodeWallet;
  }
}

// ethlab makes provider and signer available on window
declare global {
  const provider: Ethers.Provider;
  const signer: Ethers.Signer;
  const ethers: typeof Ethers;
}

export {};
